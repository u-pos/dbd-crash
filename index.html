<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Match-3 Mobile Swipe</title>
  <style>
    :root {
      --cols:8;
      --rows:8;
      --tile-size:9.5vmin;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#0f172a,#0b1220);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      color: #fff;
      -webkit-tap-highlight-color: transparent;
      touch-action: none; /* 重要：ピンチズームやスクロール防止 */
      overscroll-behavior: contain;
      user-select: none;
    }
    .wrap {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4vmin;
    }
    .ui {
      width: calc(var(--cols)*var(--tile-size) + 3vmin);
      max-width: 96vw;
      user-select:none;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 3vmin;
    }
    .panel {
      background: rgba(255,255,255,0.04);
      padding: 2vmin;
      border-radius: 12px;
      user-select:none;
    }
    .board {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent);
      padding: 6px;
      border-radius: 10px;
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--tile-size));
      gap: 4px;
      touch-action: none; /* 重要 */
    }
    .cell {
      width: var(--tile-size);
      height: var(--tile-size);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      user-select:none;
      -webkit-user-drag:none;
      touch-action: none;
      background: #111a2a;
      box-shadow: inset 0 0 8px rgba(255,255,255,0.05);
    }
    .cell img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      user-select:none;
      pointer-events:none;
      -webkit-user-drag:none;
    }
    .start-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select:none;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
    }
    .start-btn {
      background: linear-gradient(90deg,#ff7ab6,#7b61ff);
      border: none;
      padding: 12px 22px;
      border-radius: 999px;
      font-size: 1.6rem;
      color: #fff;
      box-shadow: 0 8px 30px rgba(123,97,255,0.25);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .selected {
      outline: 3px solid rgba(255,255,255,0.18);
      transform: scale(1.04);
    }
    .pop {
      animation: pop .45s cubic-bezier(.2,.9,.3,1);
    }
    @keyframes pop {
      0% {transform: scale(1)}
      50% {transform: scale(1.25); filter: brightness(1.25)}
      100% {transform: scale(1); filter: brightness(1)}
    }
    .fade-out {
      animation: fadeout .38s forwards;
    }
    @keyframes fadeout {
      0% {opacity:1; transform: scale(1)}
      100% {opacity:0; transform: scale(0.3)}
    }
    .floating {
      transition: transform 420ms cubic-bezier(.2,.8,.3,1);
    }
    .scorebox {
      font-weight: 700;
    }
    .small {
      font-size: 0.85rem;
      opacity: 0.9;
    }
    .footer {
      margin-top: 2vmin;
      text-align: center;
      opacity: 0.85;
      user-select:none;
    }
    button {
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="ui">
      <div class="header">
        <div class="panel small">Score: <span id="score" class="scorebox">0</span></div>
        <div class="panel small">Time: <span id="time">60</span>s</div>
        <div class="panel small">Combo: <span id="combo">x1.0</span></div>
      </div>

      <div id="boardWrap" style="position:relative">
        <div id="board" class="board"></div>
        <div id="overlay" class="start-overlay"><button id="startBtn" class="start-btn">START</button></div>
      </div>

      <div class="footer small">
        Match-3, 1 minute high-score. Swipe tiles to swap adjacent ones. Good luck!
      </div>
    </div>
  </div>

  <audio id="sndStart" src="c.mp3" preload="auto"></audio>
  <audio id="sndClear" src="a.mp3" preload="auto"></audio>

  <script>
  // Config
  const ROWS = 8;
  const COLS = 8;
  const TILE_TYPES = 6;
  const GAME_TIME = 60;

  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const timeEl = document.getElementById('time');
  const comboEl = document.getElementById('combo');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const sndStart = document.getElementById('sndStart');
  const sndClear = document.getElementById('sndClear');

  let board = new Array(ROWS * COLS).fill(0);
  let running = false;
  let score = 0;
  let timeLeft = GAME_TIME;
  let timerId = null;
  let combo = 1.0;
  let processing = false;

  function idx(r, c) { return r * COLS + c }
  function rc(i) { return [Math.floor(i / COLS), i % COLS] }
  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min }

  // Generate board with no immediate matches
  function generateBoard() {
    const b = new Array(ROWS * COLS).fill(0);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        let attempts = 0;
        while (true) {
          const t = randInt(1, TILE_TYPES);
          b[idx(r, c)] = t;
          let bad = false;
          if (c >= 2 && b[idx(r, c - 1)] === t && b[idx(r, c - 2)] === t) bad = true;
          if (r >= 2 && b[idx(r - 1, c)] === t && b[idx(r - 2, c)] === t) bad = true;
          if (!bad) break;
          attempts++;
          if (attempts > 30) break;
        }
      }
    }
    return b;
  }

  // Render the board, with optional animation if prevBoard given
  function renderBoard(prevBoard) {
    boardEl.innerHTML = '';
    for (let i = 0; i < board.length; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.i = i;
      const img = document.createElement('img');
      img.draggable = false;
      img.src = `tile${board[i]}.png`;
      cell.appendChild(img);
      boardEl.appendChild(cell);
    }
  }

  // Find matches: return array of indices
  function findMatches(b) {
    const toClear = new Set();

    // Horizontal
    for (let r = 0; r < ROWS; r++) {
      let runType = null, runStart = 0, runLen = 0;
      for (let c = 0; c < COLS; c++) {
        const t = b[idx(r, c)];
        if (t === runType) runLen++;
        else {
          if (runType && runLen >= 3) {
            for (let k = 0; k < runLen; k++) toClear.add(idx(r, runStart + k));
          }
          runType = t;
          runStart = c;
          runLen = 1;
        }
      }
      if (runType && runLen >= 3) {
        for (let k = 0; k < runLen; k++) toClear.add(idx(r, runStart + k));
      }
    }
    // Vertical
    for (let c = 0; c < COLS; c++) {
      let runType = null, runStart = 0, runLen = 0;
      for (let r = 0; r < ROWS; r++) {
        const t = b[idx(r, c)];
        if (t === runType) runLen++;
        else {
          if (runType && runLen >= 3) {
            for (let k = 0; k < runLen; k++) toClear.add(idx(runStart + k, c));
          }
          runType = t;
          runStart = r;
          runLen = 1;
        }
      }
      if (runType && runLen >= 3) {
        for (let k = 0; k < runLen; k++) toClear.add(idx(runStart + k, c));
      }
    }

    return Array.from(toClear).sort((a,b) => a-b);
  }

  // Collapse board and fill top with new tiles
  function collapseBoard(b) {
    const nb = b.slice();
    for (let c = 0; c < COLS; c++) {
      const col = [];
      for (let r = 0; r < ROWS; r++) {
        const v = nb[idx(r, c)];
        if (v !== 0) col.push(v);
      }
      const missing = ROWS - col.length;
      const newTiles = Array.from({length: missing}, () => randInt(1, TILE_TYPES));
      const newCol = newTiles.concat(col);
      for(let r=0; r<ROWS; r++) nb[idx(r,c)] = newCol[r];
    }
    return nb;
  }

  // Swap two indices in board and return new board array
  function swapTiles(b, i1, i2) {
    const nb = b.slice();
    const tmp = nb[i1];
    nb[i1] = nb[i2];
    nb[i2] = tmp;
    return nb;
  }

  // Scoring points by count of cleared tiles in one match set
  function scoreForMatch(count) {
    switch(count) {
      case 3: return 100;
      case 4: return 200;
      case 5: return 300;
      default: return 0;
    }
  }

  // Game state reset and start
  function startGame() {
    board = generateBoard();
    score = 0;
    timeLeft = GAME_TIME;
    combo = 1;
    processing = false;
    running = true;
    overlay.style.display = 'none';
    updateUI();
    renderBoard();
    sndStart.currentTime = 0;
    sndStart.play();
    timerId = setInterval(() => {
      timeLeft--;
      if(timeLeft <= 0) {
        clearInterval(timerId);
        running = false;
        overlay.style.display = 'flex';
        startBtn.textContent = 'RESTART';
      }
      updateUI();
    }, 1000);
  }

  function updateUI() {
    scoreEl.textContent = score;
    timeEl.textContent = timeLeft;
    comboEl.textContent = 'x' + combo.toFixed(1);
  }

  // Check if two tiles are adjacent
  function isAdjacent(i1, i2) {
    const [r1, c1] = rc(i1);
    const [r2, c2] = rc(i2);
    return (Math.abs(r1-r2) + Math.abs(c1-c2)) === 1;
  }

  // Handle a player move (swap tiles if valid and if it creates matches)
  async function playerMove(i1, i2) {
    if(!running || processing) return;
    if(!isAdjacent(i1, i2)) return;
    processing = true;

    // Swap and check matches
    let newBoard = swapTiles(board, i1, i2);
    let matches = findMatches(newBoard);

    if(matches.length === 0) {
      // no match - revert swap after short delay
      renderSwapAnimation(i1, i2, false);
      await delay(350);
      processing = false;
      return;
    }

    renderSwapAnimation(i1, i2, true);
    board = newBoard;

    // Start chain clearing loop
    let chain = 0;
    while(true) {
      matches = findMatches(board);
      if(matches.length === 0) break;
      chain++;
      // Play clear sound
      sndClear.currentTime = 0;
      sndClear.play();

      // Calculate score for this clear with combo multiplier
      const uniqueTiles = new Set(matches);
      // Count per connected groups
      const groups = groupMatches(board, matches);
      let gained = 0;
      for(let group of groups) {
        const count = group.length;
        const baseScore = scoreForMatch(count);
        gained += baseScore * Math.min(chain,10);
      }
      score += gained;
      combo = Math.min(10, chain);

      // Clear matched tiles
      for(let idx of matches) board[idx] = 0;
      renderBoard();

      // Collapse board and refill
      board = collapseBoard(board);
      renderBoard();

      await delay(450);
    }
    updateUI();
    processing = false;
  }

  // Render swap animation of two cells
  function renderSwapAnimation(i1, i2, success) {
    const cells = boardEl.children;
    const cell1 = cells[i1];
    const cell2 = cells[i2];
    if(!cell1 || !cell2) return;

    const pos1 = cell1.getBoundingClientRect();
    const pos2 = cell2.getBoundingClientRect();

    const dx = pos2.left - pos1.left;
    const dy = pos2.top - pos1.top;

    // Animate swap
    cell1.style.transition = 'transform 300ms ease';
    cell2.style.transition = 'transform 300ms ease';
    cell1.style.transform = `translate(${dx}px,${dy}px)`;
    cell2.style.transform = `translate(${-dx}px,${-dy}px)`;

    setTimeout(() => {
      cell1.style.transition = '';
      cell2.style.transition = '';
      cell1.style.transform = '';
      cell2.style.transform = '';
      if(!success) renderBoard();
    }, 300);
  }

  // Utility delay promise
  function delay(ms) {
    return new Promise(res => setTimeout(res, ms));
  }

  // Group matches into connected sets for scoring by length
  function groupMatches(board, indices) {
    // Build adjacency list of matched tiles
    const adj = {};
    indices.forEach(i => adj[i] = []);
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

    for(let i of indices) {
      const [r,c] = rc(i);
      for(let [dr,dc] of dirs) {
        const nr = r+dr, nc = c+dc;
        const ni = idx(nr,nc);
        if(indices.includes(ni)) {
          adj[i].push(ni);
        }
      }
    }

    // BFS to group connected tiles
    const visited = new Set();
    const groups = [];
    for(let i of indices) {
      if(visited.has(i)) continue;
      const queue = [i];
      const group = [];
      while(queue.length) {
        const curr = queue.shift();
        if(visited.has(curr)) continue;
        visited.add(curr);
        group.push(curr);
        for(let n of adj[curr]) if(!visited.has(n)) queue.push(n);
      }
      groups.push(group);
    }
    return groups;
  }

  // Touch / swipe handling for swap
  let touchStartIndex = null;
  let touchStartX = 0;
  let touchStartY = 0;

  boardEl.addEventListener('touchstart', e => {
    if(!running || processing) return;
    const target = e.target.closest('.cell');
    if(!target) return;
    touchStartIndex = Number(target.dataset.i);
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    e.preventDefault();
  }, { passive:false });

  boardEl.addEventListener('touchmove', e => {
    if(touchStartIndex === null) return;
    e.preventDefault();
  }, { passive:false });

  boardEl.addEventListener('touchend', e => {
    if(touchStartIndex === null || !running || processing) {
      touchStartIndex = null;
      return;
    }
    const touch = e.changedTouches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if(Math.max(absDx, absDy) < 20) {
      touchStartIndex = null;
      return;
    }
    const [r,c] = rc(touchStartIndex);
    let targetR = r;
    let targetC = c;

    if(absDx > absDy) {
      targetC += (dx > 0) ? 1 : -1;
    } else {
      targetR += (dy > 0) ? 1 : -1;
    }

    if(targetR < 0 || targetR >= ROWS || targetC < 0 || targetC >= COLS) {
      touchStartIndex = null;
      return;
    }
    const targetIndex = idx(targetR, targetC);
    playerMove(touchStartIndex, targetIndex);
    touchStartIndex = null;
  }, { passive:false });

  startBtn.addEventListener('click', startGame);

  // 初期表示
  renderBoard();
  updateUI();
  </script>
</body>
</html>
