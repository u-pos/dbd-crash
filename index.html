<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Match-3 Mobile Swipe</title>
  <style>
:root {
  --cols: 8;
  --rows: 8;
  --gap: 4px;    /* .board の gap と合わせる */
  --pad: 6px;    /* .board の padding と合わせる */
  --tile-size: calc((100vw - (var(--gap) * (var(--cols) - 1)) - (var(--pad) * 2)) / var(--cols));
}

    html, body {
　　　position: fixed; width: 100vw; height: 100vh; overflow: hidden; 
      margin: 0;
      padding: 0;
      width: 100%;
      overflow-x: hidden; /* 右にはみ出すの防止 */
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      background: #111;
      color: white;
      font-family: sans-serif;
      height: 100vh;
    }
    /* wrap を flex 中央寄せにして左右バランス修正 */
    .wrap {
      width: 100%;
      max-width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      box-sizing: border-box;
    }
    .ui {
      align-items: center;
      width: calc(var(--cols) * var(--tile-size));
      max-width: 100vw;
      user-select:none;
      position: relative;
      margin: 0 auto;
      display: flex;
  flex-direction: column;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5vw;
      font-size: 3.6vw;
      font-weight: 600;
      user-select:none;
    }
    .panel {
      background: rgba(255,255,255,0.04);
      padding: 0.8vw 1.5vw;
      border-radius: 12px;
      user-select:none;
      min-width: 28vw;
      text-align: center;
    }
    #combo {
      color: #ffde59;
      font-weight: 900;
      font-size: 4.4vw;
      user-select:none;
    }
    .board {
      margin: 0 auto;  
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent);
      padding: 6px;
      border-radius: 10px;
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--tile-size));
      gap: 4px;
      touch-action: none;
      user-select:none;
      user-drag:none;
      box-sizing: border-box;
      width: 100%;
    }
    .cell {
      width: var(--tile-size);
      height: var(--tile-size);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      user-select:none;
      -webkit-user-drag:none;
      touch-action: none;
      background: #111a2a;
      box-shadow: inset 0 0 8px rgba(255,255,255,0.05);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .cell img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      user-select:none;
      pointer-events:none;
      -webkit-user-drag:none;
      transform-origin: center center;
      will-change: transform, opacity;
    }

    /* vanish アニメ（拡大→フェード） */
    @keyframes vanish {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.25); opacity: 0.6; }
      100% { transform: scale(0); opacity: 0; }
    }
    .vanish {
      animation: vanish 120ms cubic-bezier(.2,.9,.3,1) forwards;
    }

    /* drop 用 transition（JS で transform をセットして動かす）*/
    .drop {
      transition: transform 150ms cubic-bezier(.2,.8,.3,1);
    }

    .start-overlay, #gameOverOverlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select:none;
      background: rgba(0,0,0,0.35);
      border-radius: 10px;
      flex-direction: column;
      z-index: 10;
    }
    .start-btn {
      background: linear-gradient(90deg,#ff7ab6,#7b61ff);
      border: none;
      padding: 14px 26px;
      border-radius: 999px;
      font-size: 1.8rem;
      color: #fff;
      box-shadow: 0 8px 30px rgba(123,97,255,0.25);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      margin-top: 1.5vw;
    }
    .scorebox {
      font-weight: 700;
    }
    .footer {
      margin-top: 2vw;
      text-align: center;
      opacity: 0.85;
      user-select:none;
      font-size: 3vw;
    }

    /* ゲーム終了オーバーレイのスコア大表示 */
    #gameOverOverlay {
      font-size: 10vw;
      font-weight: 900;
      color: #fff;
      user-select:none;
      flex-wrap: wrap;
      gap: 1vw;
      text-align: center;
      line-height: 1.1;
    }
    #gameOverOverlay button {
      font-size: 5vw;
      margin-top: 3vw;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="ui">
      <div class="header" role="banner">
        <div class="panel" id="scorePanel">Score: <span id="score" class="scorebox">0</span></div>
        <div class="panel" id="timePanel">残り <span id="time">60</span> 秒</div>
        <div class="panel" id="comboPanel"><span id="combo"></span></div>
      </div>

      <div id="boardWrap" style="position:relative; touch-action:none;">
        <div id="board" class="board" aria-label="ゲームボード" role="grid"></div>
        <div id="overlay" class="start-overlay" aria-hidden="false">
          <button id="startBtn" class="start-btn" aria-label="ゲーム開始ボタン">START</button>
        </div>
        <div id="gameOverOverlay" style="display:none;" aria-live="assertive" aria-atomic="true"></div>
      </div>
     <div class="footer" aria-live="polite" aria-atomic="true" style="color:#fff; font-size:3vw; padding:0;">
  <table style="width:100%; border-collapse: collapse; color: #fff; text-align: center;">
    <thead>
      <tr>
        <th style="border-bottom: 2px solid #ffde59; padding: 0.5rem;">得点ルール</th>
        <th style="border-bottom: 2px solid #ffde59; padding: 0.5rem;">内容</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border-bottom: 1px solid #555; padding: 0.5rem;">3個消し</td>
        <td style="border-bottom: 1px solid #555; padding: 0.5rem;">100点</td>
      </tr>
      <tr>
        <td style="border-bottom: 1px solid #555; padding: 0.5rem;">4個消し</td>
        <td style="border-bottom: 1px solid #555; padding: 0.5rem;">200点</td>
      </tr>
      <tr>
        <td style="border-bottom: 1px solid #555; padding: 0.5rem;">5個消し</td>
        <td style="border-bottom: 1px solid #555; padding: 0.5rem;">300点</td>
      </tr>
      <tr>
        <td colspan="2" style="border-bottom: 1px solid #555; padding: 0.5rem;">2連鎖目は得点2倍、3連鎖目は得点3倍入ります。<br />※4コンボ目で3個消えたら1200点入ります。</td>
      </tr>
    </tbody>
  </table>
</div>

    </div>
  </div>

  <audio id="sndStart" src="s.mp3" preload="auto"></audio>
  <audio id="sndClear" src="cc.mp3" preload="auto"></audio>
  <audio id="bgm" src="bgm2.mp3" preload="auto" loop></audio>

  <script>
  // Config
  const ROWS = 8;
  const COLS = 8;
  const TILE_TYPES = 6;
  const GAME_TIME = 60;

  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const timeEl = document.getElementById('time');
  const comboEl = document.getElementById('combo');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const sndStart = document.getElementById('sndStart');
  const sndClear = document.getElementById('sndClear');
  const bgm = document.getElementById('bgm');
  const gameOverOverlay = document.getElementById('gameOverOverlay');

  bgm.volume = 0.2;

  let board = new Array(ROWS * COLS).fill(0);
  let running = false;
  let score = 0;
  let timeLeft = GAME_TIME;
  let timerId = null;
  let combo = 1.0;
  let processing = false;

  function idx(r, c) { return r * COLS + c }
  function rc(i) { return [Math.floor(i / COLS), i % COLS] }
  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min }

  // Generate board with no immediate matches
  function generateBoard() {
    const b = new Array(ROWS * COLS).fill(0);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        let attempts = 0;
        while (true) {
          const t = randInt(1, TILE_TYPES);
          b[idx(r,c)] = t;
          let bad = false;
          if (c >= 2 && b[idx(r,c-1)] === t && b[idx(r,c-2)] === t) bad = true;
          if (r >= 2 && b[idx(r-1,c)] === t && b[idx(r-2,c)] === t) bad = true;
          if(!bad) break;
          attempts++;
          if(attempts > 20) break;
        }
      }
    }
    return b;
  }

  // Find matches in board, returns array of indices to clear
  function findMatches(b) {
    const toClear = new Set();
    // Horizontal
    for(let r=0; r<ROWS; r++) {
      let runType = null, runStart = 0, runLen = 0;
      for(let c=0; c<COLS; c++) {
        const t = b[idx(r,c)];
        if(t === runType) runLen++;
        else {
          if(runType && runLen >= 3) {
            for(let k=0; k<runLen; k++) toClear.add(idx(r,runStart+k));
          }
          runType = t;
          runStart = c;
          runLen = 1;
        }
      }
      if(runType && runLen >= 3) {
        for(let k=0; k<runLen; k++) toClear.add(idx(r,runStart+k));
      }
    }
    // Vertical
    for(let c=0; c<COLS; c++) {
      let runType = null, runStart = 0, runLen = 0;
      for(let r=0; r<ROWS; r++) {
        const t = b[idx(r,c)];
        if(t === runType) runLen++;
        else {
          if(runType && runLen >= 3) {
            for(let k=0; k<runLen; k++) toClear.add(idx(runStart+k,c));
          }
          runType = t;
          runStart = r;
          runLen = 1;
        }
      }
      if(runType && runLen >= 3) {
        for(let k=0; k<runLen; k++) toClear.add(idx(runStart+k,c));
      }
    }
    return Array.from(toClear).sort((a,b) => a-b);
  }

  // Collapse board, drop tiles and fill top with new tiles
  function collapseBoard(b) {
    const nb = b.slice();
    for(let c=0; c<COLS; c++) {
      const col = [];
      for(let r=0; r<ROWS; r++) {
        const v = nb[idx(r,c)];
        if(v !== 0) col.push(v);
      }
      const missing = ROWS - col.length;
      const newTiles = Array.from({length: missing}, () => randInt(1, TILE_TYPES));
      const newCol = newTiles.concat(col);
      for(let r=0; r<ROWS; r++) nb[idx(r,c)] = newCol[r];
    }
    return nb;
  }

  // Swap two tiles in board
  function swapTiles(b, i1, i2) {
    const nb = b.slice();
    const tmp = nb[i1];
    nb[i1] = nb[i2];
    nb[i2] = tmp;
    return nb;
  }

  // Score by match count
  function scoreForMatch(count) {
    switch(count) {
      case 3: return 100;
      case 4: return 200;
      case 5: return 300;
      default: return 0;
    }
  }

  // Render the board, optionally animating drops when prevBoard provided
  function renderBoard(prevBoard) {
    boardEl.innerHTML = '';
    for(let i=0; i<board.length; i++) {
      const t = board[i];
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.i = i;
      if(t > 0) {
        const img = document.createElement('img');
        img.src = `tile${t}.png`;
        img.alt = `タイル${t}`;
        // If prevBoard provided and prevBoard[i] === 0 and board[i] > 0 -> new/fallen tile: animate drop from above
        if(prevBoard && prevBoard[i] === 0) {
          img.style.transform = 'translateY(-120%)';
          img.classList.add('drop');
          // ensure transition runs
          requestAnimationFrame(()=> {
            img.style.transform = 'translateY(0)';
          });
          // remove transition after it's done to avoid interfering with future transforms
          img.addEventListener('transitionend', function te(){
            img.classList.remove('drop');
            img.style.transform = '';
            img.removeEventListener('transitionend', te);
          });
        }
        cell.appendChild(img);
      }
      boardEl.appendChild(cell);
    }
  }

  // wait for animationend on a list of elements, with timeout fallback
  function waitForAnimations(elements, timeout = 600) {
    return new Promise(resolve => {
      if(!elements || elements.length === 0) return resolve();
      let remaining = elements.length;
      const timers = [];
      const onEnd = (ev) => {
        ev.currentTarget.removeEventListener('animationend', onEnd);
        remaining--;
        if(remaining <= 0) {
          timers.forEach(t => clearTimeout(t));
          resolve();
        }
      };
      elements.forEach(el => {
        // if element already null (no img), treat as ended
        if(!el) { remaining--; return; }
        el.addEventListener('animationend', onEnd);
        // timeout fallback
        const t = setTimeout(()=> {
          try { el.removeEventListener('animationend', onEnd); }catch(e){}
          remaining--;
          if(remaining <= 0) resolve();
        }, timeout);
        timers.push(t);
      });
      if(remaining <= 0) resolve();
    });
  }

  // Start game
  function startGame() {
    bgm.currentTime = 0;
    bgm.play().catch(() => {});
    board = generateBoard();
    score = 0;
    timeLeft = GAME_TIME;
    combo = 1;
    processing = false;
    running = true;
    overlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    updateUI();
    renderBoard();
    sndStart.currentTime = 0;
    sndStart.play();
    timerId = setInterval(() => {
      timeLeft--;
      if(timeLeft <= 0) {
        clearInterval(timerId);
        running = false;
        showGameOver();
      }
      updateUI();
    }, 1000);
  }

  function updateUI() {
    scoreEl.textContent = score;
    timeEl.textContent = timeLeft;
    comboEl.textContent = combo > 1 ? `${Math.floor(combo)}コンボ！` : '';
    document.getElementById('timePanel').textContent = `残り ${timeLeft} 秒`;
  }

  function showGameOver() {
    bgm.pause();
    gameOverOverlay.style.display = 'flex';
    gameOverOverlay.innerHTML = `
      <div>最終スコア</div>
      <div style="font-size: 15vw; font-weight: 900; margin-top: 0.5em;">${score}</div>
      <button id="restartBtn" class="start-btn">RESTART</button>
    `;
    overlay.style.display = 'none';
    document.getElementById('restartBtn').addEventListener('click', () => {
      startGame();
      gameOverOverlay.style.display = 'none';
    });
  }

  // Check adjacency
  function isAdjacent(i1,i2) {
    const [r1,c1] = rc(i1);
    const [r2,c2] = rc(i2);
    return (Math.abs(r1-r2)+Math.abs(c1-c2))===1;
  }

  // Player move: swap and clear if valid (with vanish & drop animations)
  async function playerMove(i1, i2) {
    if(!running || processing) return;
    if(!isAdjacent(i1,i2)) return;
    processing = true;

    // Swap board and check matches
    let newBoard = swapTiles(board,i1,i2);
    let matches = findMatches(newBoard);

    if(matches.length === 0) {
      // No match, revert swap with animation
      renderSwapAnimation(i1,i2,false);
      await delay(350);
      processing = false;
      return;
    }

    renderSwapAnimation(i1,i2,true);
    board = newBoard;

    // Play clear sound immediately after swap if match
    sndClear.currentTime = 0;
    sndClear.play();

    let chain = 0;
    while(true) {
      matches = findMatches(board);
      if(matches.length === 0) break;
      chain++;

      // Play clear sound on each chain
      sndClear.currentTime = 0;
      sndClear.play();

      // Score calculation: group matches and multiply by chain number capped at 10
      const groups = groupMatches(board, matches);
      let gained = 0;
      for(let group of groups) {
        const count = group.length;
        const baseScore = scoreForMatch(count);
        gained += baseScore * Math.min(chain, 10);
      }
      score += gained;
      combo = Math.min(10, chain);

      // --- ANIMATION: vanish matched tiles (use DOM elements) ---
      // Capture images for matched indices
      const imgEls = matches.map(i => {
        const cell = boardEl.querySelector(`.cell[data-i='${i}']`);
        return cell ? cell.querySelector('img') : null;
      }).filter(Boolean);
      // Add vanish class
      imgEls.forEach(img => {
        // ensure reflow so animation restarts if re-added
        img.classList.remove('vanish');
        void img.offsetWidth;
        img.classList.add('vanish');
      });
      // wait for animation end (or fallback)
      await waitForAnimations(imgEls, 500);

      // After vanish animations, clear those indices from board
      for(let idx of matches) board[idx] = 0;

      // Save prev state after clear (slots empty) to animate drops relative to it
      const prevAfterClear = board.slice();

      // Collapse and refill board
      board = collapseBoard(board);

      // Render with prevAfterClear so renderBoard can detect new tiles and animate drop
      renderBoard(prevAfterClear);

      await delay(480);
    }
    updateUI();
    processing = false;
  }

  // Render swap animation
  function renderSwapAnimation(i1, i2, success) {
    const cells = boardEl.children;
    const cell1 = cells[i1];
    const cell2 = cells[i2];
    if(!cell1 || !cell2) return;

    const pos1 = cell1.getBoundingClientRect();
    const pos2 = cell2.getBoundingClientRect();

    const dx = pos2.left - pos1.left;
    const dy = pos2.top - pos1.top;

    cell1.style.transition = 'transform 300ms ease';
    cell2.style.transition = 'transform 300ms ease';
    cell1.style.transform = `translate(${dx}px,${dy}px)`;
    cell2.style.transform = `translate(${-dx}px,${-dy}px)`;

    setTimeout(() => {
      cell1.style.transition = '';
      cell2.style.transition = '';
      cell1.style.transform = '';
      cell2.style.transform = '';
      if(!success) renderBoard();
    }, 300);
  }

  function delay(ms) {
    return new Promise(res => setTimeout(res, ms));
  }

  // Group connected matches for scoring
  function groupMatches(boardArr, indices) {
    const adj = {};
    indices.forEach(i => adj[i] = []);
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

    for(let i of indices) {
      const [r,c] = rc(i);
      for(let [dr,dc] of dirs) {
        const nr = r+dr, nc = c+dc;
        const ni = idx(nr,nc);
        if(indices.includes(ni)) adj[i].push(ni);
      }
    }

    const visited = new Set();
    const groups = [];
    for(let i of indices) {
      if(visited.has(i)) continue;
      const queue = [i];
      const group = [];
      while(queue.length) {
        const curr = queue.shift();
        if(visited.has(curr)) continue;
        visited.add(curr);
        group.push(curr);
        for(let n of adj[curr]) if(!visited.has(n)) queue.push(n);
      }
      groups.push(group);
    }
    return groups;
  }

  // Touch/swipe handling
  let touchStartIndex = null;
  let touchStartX = 0;
  let touchStartY = 0;

  boardEl.addEventListener('touchstart', e => {
    if(!running || processing) return;
    const target = e.target.closest('.cell');
    if(!target) return;
    touchStartIndex = Number(target.dataset.i);
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    e.preventDefault();
  }, { passive:false });

  boardEl.addEventListener('touchmove', e => {
    if(touchStartIndex === null) return;
    e.preventDefault();
  }, { passive:false });

  boardEl.addEventListener('touchend', e => {
    if(touchStartIndex === null || !running || processing) {
      touchStartIndex = null;
      return;
    }
    const touch = e.changedTouches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if(Math.max(absDx, absDy) < 20) {
      touchStartIndex = null;
      return;
    }
    const [r,c] = rc(touchStartIndex);
    let targetR = r;
    let targetC = c;

    if(absDx > absDy) {
      targetC += (dx > 0) ? 1 : -1;
    } else {
      targetR += (dy > 0) ? 1 : -1;
    }

    if(targetR < 0 || targetR >= ROWS || targetC < 0 || targetC >= COLS) {
      touchStartIndex = null;
      return;
    }
    const targetIndex = idx(targetR, targetC);
    playerMove(touchStartIndex, targetIndex);
    touchStartIndex = null;
  }, { passive:false });

  // 初期レンダリング
  function renderBoardInitial() {
    board = generateBoard();
    renderBoard();
  }

  // Updated renderBoard function is above; provide wrapper to call it simply
  renderBoardInitial();
  updateUI();

  startBtn.addEventListener('click', startGame);
  </script>
</body>
</html>
