<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Match-3 Mobile Swipe</title>
  <style>
    :root {
      --cols:8;
      --rows:8;
      --tile-size:11vw; /* 画面幅基準に拡大 */
    }
    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#0f172a,#0b1220);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      color: #fff;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      overscroll-behavior: contain;
      user-select: none;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
  padding: 0;
    }
    .wrap {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      box-sizing: border-box;
      user-select:none;
    }
    .ui {
      width: calc(var(--cols)*var(--tile-size) + 3vw);
      max-width: 100vw;
      user-select:none;
      position: relative;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5vw;
      font-size: 3.6vw;
      font-weight: 600;
      user-select:none;
    }
    .panel {
      background: rgba(255,255,255,0.04);
      padding: 0.8vw 1.5vw;
      border-radius: 12px;
      user-select:none;
      min-width: 28vw;
      text-align: center;
    }
    #combo {
      color: #ffde59;
      font-weight: 900;
      font-size: 4.4vw;
      user-select:none;
    }
    .board {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent);
      padding: 6px;
      border-radius: 10px;
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--tile-size));
      gap: 4px;
      touch-action: none;
      user-select:none;
      user-drag:none;
    }
    .cell {
      width: var(--tile-size);
      height: var(--tile-size);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      user-select:none;
      -webkit-user-drag:none;
      touch-action: none;
      background: #111a2a;
      box-shadow: inset 0 0 8px rgba(255,255,255,0.05);
    }
    .cell img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      user-select:none;
      pointer-events:none;
      -webkit-user-drag:none;
    }
    .start-overlay, #gameOverOverlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select:none;
      background: rgba(0,0,0,0.35);
      border-radius: 10px;
      flex-direction: column;
      z-index: 10;
    }
    .start-btn {
      background: linear-gradient(90deg,#ff7ab6,#7b61ff);
      border: none;
      padding: 14px 26px;
      border-radius: 999px;
      font-size: 1.8rem;
      color: #fff;
      box-shadow: 0 8px 30px rgba(123,97,255,0.25);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      margin-top: 1.5vw;
    }
    .scorebox {
      font-weight: 700;
    }
    .footer {
      margin-top: 2vw;
      text-align: center;
      opacity: 0.85;
      user-select:none;
      font-size: 3vw;
    }

    /* ゲーム終了オーバーレイのスコア大表示 */
    #gameOverOverlay {
      font-size: 10vw;
      font-weight: 900;
      color: #fff;
      user-select:none;
      flex-wrap: wrap;
      gap: 1vw;
      text-align: center;
      line-height: 1.1;
    }
    #gameOverOverlay button {
      font-size: 5vw;
      margin-top: 3vw;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="ui">
      <div class="header" role="banner">
        <div class="panel" id="scorePanel">Score: <span id="score" class="scorebox">0</span></div>
        <div class="panel" id="timePanel">残り <span id="time">60</span> 秒</div>
        <div class="panel" id="comboPanel"><span id="combo"></span></div>
      </div>

      <div id="boardWrap" style="position:relative; touch-action:none;">
        <div id="board" class="board" aria-label="ゲームボード" role="grid"></div>
        <div id="overlay" class="start-overlay" aria-hidden="false">
          <button id="startBtn" class="start-btn" aria-label="ゲーム開始ボタン">START</button>
        </div>
        <div id="gameOverOverlay" style="display:none;" aria-live="assertive" aria-atomic="true"></div>
      </div>

      <div class="footer" aria-live="polite" aria-atomic="true">
        Match-3, 1分間の高得点チャレンジ。スワイプで隣接するタイルと入れ替えよう！
      </div>
    </div>
  </div>

  <audio id="sndStart" src="s.mp3" preload="auto"></audio>
  <audio id="sndClear" src="cc.mp3" preload="auto"></audio>
<audio id="bgm" src="bgm.mp3" preload="auto" loop></audio>

  <script>
  // Config
  const ROWS = 8;
  const COLS = 8;
  const TILE_TYPES = 6;
  const GAME_TIME = 60;

  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const timeEl = document.getElementById('time');
  const comboEl = document.getElementById('combo');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const sndStart = document.getElementById('sndStart');
  const sndClear = document.getElementById('sndClear');
  const gameOverOverlay = document.getElementById('gameOverOverlay');

  let board = new Array(ROWS * COLS).fill(0);
  let running = false;
  let score = 0;
  let timeLeft = GAME_TIME;
  let timerId = null;
  let combo = 1.0;
  let processing = false;

  function idx(r, c) { return r * COLS + c }
  function rc(i) { return [Math.floor(i / COLS), i % COLS] }
  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min }

  // Generate board with no immediate matches
  function generateBoard() {
    const b = new Array(ROWS * COLS).fill(0);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        let attempts = 0;
        while (true) {
          const t = randInt(1, TILE_TYPES);
          b[idx(r,c)] = t;
          let bad = false;
          if (c >= 2 && b[idx(r,c-1)] === t && b[idx(r,c-2)] === t) bad = true;
          if (r >= 2 && b[idx(r-1,c)] === t && b[idx(r-2,c)] === t) bad = true;
          if(!bad) break;
          attempts++;
          if(attempts > 20) break;
        }
      }
    }
    return b;
  }

  // Find matches in board, returns array of indices to clear
  function findMatches(b) {
    const toClear = new Set();
    // Horizontal
    for(let r=0; r<ROWS; r++) {
      let runType = null, runStart = 0, runLen = 0;
      for(let c=0; c<COLS; c++) {
        const t = b[idx(r,c)];
        if(t === runType) runLen++;
        else {
          if(runType && runLen >= 3) {
            for(let k=0; k<runLen; k++) toClear.add(idx(r,runStart+k));
          }
          runType = t;
          runStart = c;
          runLen = 1;
        }
      }
      if(runType && runLen >= 3) {
        for(let k=0; k<runLen; k++) toClear.add(idx(r,runStart+k));
      }
    }
    // Vertical
    for(let c=0; c<COLS; c++) {
      let runType = null, runStart = 0, runLen = 0;
      for(let r=0; r<ROWS; r++) {
        const t = b[idx(r,c)];
        if(t === runType) runLen++;
        else {
          if(runType && runLen >= 3) {
            for(let k=0; k<runLen; k++) toClear.add(idx(runStart+k,c));
          }
          runType = t;
          runStart = r;
          runLen = 1;
        }
      }
      if(runType && runLen >= 3) {
        for(let k=0; k<runLen; k++) toClear.add(idx(runStart+k,c));
      }
    }
    return Array.from(toClear).sort((a,b) => a-b);
  }

  // Collapse board, drop tiles and fill top with new tiles
  function collapseBoard(b) {
    const nb = b.slice();
    for(let c=0; c<COLS; c++) {
      const col = [];
      for(let r=0; r<ROWS; r++) {
        const v = nb[idx(r,c)];
        if(v !== 0) col.push(v);
      }
      const missing = ROWS - col.length;
      const newTiles = Array.from({length: missing}, () => randInt(1, TILE_TYPES));
      const newCol = newTiles.concat(col);
      for(let r=0; r<ROWS; r++) nb[idx(r,c)] = newCol[r];
    }
    return nb;
  }

  // Swap two tiles in board
  function swapTiles(b, i1, i2) {
    const nb = b.slice();
    const tmp = nb[i1];
    nb[i1] = nb[i2];
    nb[i2] = tmp;
    return nb;
  }

  // Score by match count
  function scoreForMatch(count) {
    switch(count) {
      case 3: return 100;
      case 4: return 200;
      case 5: return 300;
      default: return 0;
    }
  }

  // Start game
  function startGame() {
    bgm.currentTime = 0;
  bgm.volume = 0.2;
  bgm.play().catch(() => {});
    board = generateBoard();
    score = 0;
    timeLeft = GAME_TIME;
    combo = 1;
    processing = false;
    running = true;
    overlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    updateUI();
    renderBoard();
    sndStart.currentTime = 0;
    sndStart.play();
    timerId = setInterval(() => {
      timeLeft--;
      if(timeLeft <= 0) {
        clearInterval(timerId);
        running = false;
        showGameOver();
      }
      updateUI();
    }, 1000);
  }

  function updateUI() {
    scoreEl.textContent = score;
    timeEl.textContent = timeLeft;
    comboEl.textContent = combo > 1 ? `${Math.floor(combo)}コンボ！` : '';
    // Time表示を「残り◯秒」に変更
    document.getElementById('timePanel').textContent = `残り ${timeLeft} 秒`;
  }

  function showGameOver() {
    gameOverOverlay.style.display = 'flex';
    gameOverOverlay.innerHTML = `
      <div>最終スコア</div>
      <div style="font-size: 15vw; font-weight: 900; margin-top: 0.5em;">${score}</div>
      <button id="restartBtn" class="start-btn">RESTART</button>
    `;
    overlay.style.display = 'none';
    document.getElementById('restartBtn').addEventListener('click', () => {
      startGame();
      gameOverOverlay.style.display = 'none';
    });
  }

  // Check adjacency
  function isAdjacent(i1,i2) {
    const [r1,c1] = rc(i1);
    const [r2,c2] = rc(i2);
    return (Math.abs(r1-r2)+Math.abs(c1-c2))===1;
  }

  // Player move: swap and clear if valid
  async function playerMove(i1, i2) {
    if(!running || processing) return;
    if(!isAdjacent(i1,i2)) return;
    processing = true;

    // Swap board and check matches
    let newBoard = swapTiles(board,i1,i2);
    let matches = findMatches(newBoard);

    if(matches.length === 0) {
      // No match, revert swap with animation
      renderSwapAnimation(i1,i2,false);
      await delay(350);
      processing = false;
      return;
    }

    renderSwapAnimation(i1,i2,true);
    board = newBoard;

    // Play clear sound immediately after swap if match
    sndClear.currentTime = 0;
    sndClear.play();

    let chain = 0;
    while(true) {
      matches = findMatches(board);
      if(matches.length === 0) break;
      chain++;

      // Play clear sound on each chain
      sndClear.currentTime = 0;
      sndClear.play();

      // Score calculation: group matches and multiply by chain number capped at 10
      const groups = groupMatches(board, matches);
      let gained = 0;
      for(let group of groups) {
        const count = group.length;
        const baseScore = scoreForMatch(count);
        gained += baseScore * Math.min(chain, 10);
      }
      score += gained;
      combo = Math.min(10, chain);

      // Clear matched tiles
      for(let idx of matches) board[idx] = 0;
      renderBoard();

      // Collapse and refill board
      board = collapseBoard(board);
      renderBoard();

      await delay(450);
    }
    updateUI();
    processing = false;
  }

  // Render swap animation
  function renderSwapAnimation(i1, i2, success) {
    const cells = boardEl.children;
    const cell1 = cells[i1];
    const cell2 = cells[i2];
    if(!cell1 || !cell2) return;

    const pos1 = cell1.getBoundingClientRect();
    const pos2 = cell2.getBoundingClientRect();

    const dx = pos2.left - pos1.left;
    const dy = pos2.top - pos1.top;

    cell1.style.transition = 'transform 300ms ease';
    cell2.style.transition = 'transform 300ms ease';
    cell1.style.transform = `translate(${dx}px,${dy}px)`;
    cell2.style.transform = `translate(${-dx}px,${-dy}px)`;

    setTimeout(() => {
      cell1.style.transition = '';
      cell2.style.transition = '';
      cell1.style.transform = '';
      cell2.style.transform = '';
      if(!success) renderBoard();
    }, 300);
  }

  function delay(ms) {
    return new Promise(res => setTimeout(res, ms));
  }

  // Group connected matches for scoring
  function groupMatches(board, indices) {
    const adj = {};
    indices.forEach(i => adj[i] = []);
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

    for(let i of indices) {
      const [r,c] = rc(i);
      for(let [dr,dc] of dirs) {
        const nr = r+dr, nc = c+dc;
        const ni = idx(nr,nc);
        if(indices.includes(ni)) adj[i].push(ni);
      }
    }

    const visited = new Set();
    const groups = [];
    for(let i of indices) {
      if(visited.has(i)) continue;
      const queue = [i];
      const group = [];
      while(queue.length) {
        const curr = queue.shift();
        if(visited.has(curr)) continue;
        visited.add(curr);
        group.push(curr);
        for(let n of adj[curr]) if(!visited.has(n)) queue.push(n);
      }
      groups.push(group);
    }
    return groups;
  }

  // Touch/swipe handling
  let touchStartIndex = null;
  let touchStartX = 0;
  let touchStartY = 0;

  boardEl.addEventListener('touchstart', e => {
    if(!running || processing) return;
    const target = e.target.closest('.cell');
    if(!target) return;
    touchStartIndex = Number(target.dataset.i);
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    e.preventDefault();
  }, { passive:false });

  boardEl.addEventListener('touchmove', e => {
    if(touchStartIndex === null) return;
    e.preventDefault();
  }, { passive:false });

  boardEl.addEventListener('touchend', e => {
    if(touchStartIndex === null || !running || processing) {
      touchStartIndex = null;
      return;
    }
    const touch = e.changedTouches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if(Math.max(absDx, absDy) < 20) {
      touchStartIndex = null;
      return;
    }
    const [r,c] = rc(touchStartIndex);
    let targetR = r;
    let targetC = c;

    if(absDx > absDy) {
      targetC += (dx > 0) ? 1 : -1;
    } else {
      targetR += (dy > 0) ? 1 : -1;
    }

    if(targetR < 0 || targetR >= ROWS || targetC < 0 || targetC >= COLS) {
      touchStartIndex = null;
      return;
    }
    const targetIndex = idx(targetR, targetC);
    playerMove(touchStartIndex, targetIndex);
    touchStartIndex = null;
  }, { passive:false });

  // 初期レンダリング
  function renderBoard() {
    boardEl.innerHTML = '';
    for(let i=0; i<board.length; i++) {
      const t = board[i];
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.i = i;
      if(t > 0) {
        const img = document.createElement('img');
        img.src = `tile${t}.png`;
        img.alt = `タイル${t}`;
        cell.appendChild(img);
      }
      boardEl.appendChild(cell);
    }
  }

  // 最初の画面の状態をセット
  renderBoard();
  updateUI();

  startBtn.addEventListener('click', startGame);
  </script>
</body>
</html>
