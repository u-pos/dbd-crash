<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>マッチ3ゲーム（6種類キャラ）</title>
<style>
  body {
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    background: #f0f8ff;
    max-width: 600px;
    margin: 1rem auto;
    padding: 1rem;
    user-select: none;
  }
  h1 {
    text-align: center;
    margin-bottom: 1rem;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    gap: 4px;
    justify-content: center;
    margin-bottom: 1rem;
  }
  .tile {
    width: 60px;
    height: 60px;
    border-radius: 30px;
    background-size: cover;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
    transition: transform 0.2s ease;
  }
  .tile.selected {
    outline: 3px solid #4a90e2;
    transform: scale(1.1);
    z-index: 10;
  }
  #message {
    text-align: center;
    font-weight: bold;
    height: 1.5rem;
    color: #444;
  }
  #resetBtn {
    display: block;
    margin: 0 auto;
    padding: 0.6rem 1.2rem;
    font-size: 1rem;
    border-radius: 6px;
    border: none;
    background-color: #4a90e2;
    color: white;
    cursor: pointer;
  }
</style>
</head>
<body>

<h1>マッチ3ゲーム（6種類キャラ）</h1>
<div id="game"></div>
<div id="message"></div>
<button id="resetBtn">リセット</button>

<script>
const ROWS = 8;
const COLS = 8;
const TYPES = 6; // タイル種類数

// 6種類の画像ファイル名（実際に切り出して同じフォルダに置いてね）
const tileImages = [
  'tile1.png',
  'tile2.png',
  'tile3.png',
  'tile4.png',
  'tile5.png',
  'tile6.png',
];

let board = [];
let selected = null;
const gameDiv = document.getElementById('game');
const messageDiv = document.getElementById('message');
const resetBtn = document.getElementById('resetBtn');

function randomTile() {
  return Math.floor(Math.random() * TYPES);
}

// ボードを初期化（3つ以上連続しないように簡単に作る）
function initBoard() {
  board = [];
  for (let r = 0; r < ROWS; r++) {
    board[r] = [];
    for (let c = 0; c < COLS; c++) {
      let tile;
      do {
        tile = randomTile();
      } while (
        (c >= 2 && board[r][c-1] === tile && board[r][c-2] === tile) ||
        (r >= 2 && board[r-1][c] === tile && board[r-2][c] === tile)
      );
      board[r][c] = tile;
    }
  }
}

// ボードを画面に表示
function renderBoard() {
  gameDiv.innerHTML = '';
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const tile = document.createElement('div');
      tile.classList.add('tile');
      tile.style.backgroundImage = `url(${tileImages[board[r][c]]})`;
      tile.dataset.row = r;
      tile.dataset.col = c;
      tile.addEventListener('click', () => tileClicked(r, c));
      if (selected && selected.row === r && selected.col === c) {
        tile.classList.add('selected');
      }
      gameDiv.appendChild(tile);
    }
  }
}

function tileClicked(r, c) {
  if (!selected) {
    selected = { row: r, col: c };
    renderBoard();
    return;
  }
  // 隣接チェック
  if (isAdjacent(selected.row, selected.col, r, c)) {
    swapTiles(selected, {row: r, col: c});
    if (!checkMatches()) {
      // マッチしなければ元に戻す
      swapTiles(selected, {row: r, col: c});
      messageDiv.textContent = 'マッチしません！';
      setTimeout(() => { messageDiv.textContent = ''; }, 1000);
    } else {
      messageDiv.textContent = 'マッチ成功！';
      collapseBoard();
    }
    selected = null;
    renderBoard();
  } else {
    // 隣接してなければ選択し直し
    selected = { row: r, col: c };
    renderBoard();
  }
}

function isAdjacent(r1, c1, r2, c2) {
  return (Math.abs(r1 - r2) + Math.abs(c1 - c2)) === 1;
}

function swapTiles(pos1, pos2) {
  const temp = board[pos1.row][pos1.col];
  board[pos1.row][pos1.col] = board[pos2.row][pos2.col];
  board[pos2.row][pos2.col] = temp;
}

// マッチ3チェック（縦横3つ以上同じか）
function checkMatches() {
  let matched = false;
  const toClear = [];

  // 横チェック
  for (let r = 0; r < ROWS; r++) {
    let count = 1;
    for (let c = 1; c < COLS; c++) {
      if (board[r][c] === board[r][c-1]) {
        count++;
      } else {
        if (count >= 3) {
          matched = true;
          for(let k = 0; k < count; k++) toClear.push({r, c: c-1-k});
        }
        count = 1;
      }
    }
    if (count >=3) {
      matched = true;
      for(let k = 0; k < count; k++) toClear.push({r, c: COLS-1-k});
    }
  }

  // 縦チェック
  for (let c = 0; c < COLS; c++) {
    let count = 1;
    for (let r = 1; r < ROWS; r++) {
      if (board[r][c] === board[r-1][c]) {
        count++;
      } else {
        if (count >= 3) {
          matched = true;
          for(let k = 0; k < count; k++) toClear.push({r: r-1-k, c});
        }
        count = 1;
      }
    }
    if (count >= 3) {
      matched = true;
      for(let k = 0; k < count; k++) toClear.push({r: ROWS-1-k, c});
    }
  }

  // 消すマスを空に
  toClear.forEach(({r, c}) => {
    board[r][c] = -1;
  });

  return matched;
}

// 消したマスを落とす処理
function collapseBoard() {
  for (let c = 0; c < COLS; c++) {
    let pointer = ROWS - 1;
    for (let r = ROWS - 1; r >= 0; r--) {
      if (board[r][c] !== -1) {
        board[pointer][c] = board[r][c];
        pointer--;
      }
    }
    for (let r = pointer; r >= 0; r--) {
      board[r][c] = randomTile();
    }
  }

  // 落ちたあと、連鎖チェック（自動）
  if (checkMatches()) {
    setTimeout(() => {
      collapseBoard();
      renderBoard();
    }, 500);
  } else {
    renderBoard();
  }
}

resetBtn.addEventListener('click', () => {
  selected = null;
  messageDiv.textContent = '';
  initBoard();
  renderBoard();
});

initBoard();
renderBoard();
</script>
</body>
</html>
