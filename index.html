
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Match-3 Mobile</title>
  <style>
    :root{--cols:8;--rows:8;--tile-size:9.5vmin}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0f172a,#0b1220);font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo,sans-serif;color:#fff}
    .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:4vmin}
    .ui{width:calc(var(--cols)*var(--tile-size) + 3vmin);max-width:96vw}
    .header{display:flex;justify-content:space-between;align-items:center;margin-bottom:3vmin}
    .panel{background:rgba(255,255,255,0.04);padding:2vmin;border-radius:12px}
    .board{background:linear-gradient(180deg, rgba(255,255,255,0.03), transparent);padding:6px;border-radius:10px;display:grid;grid-template-columns:repeat(var(--cols), var(--tile-size));gap:4px}
    .cell{width:var(--tile-size);height:var(--tile-size);border-radius:8px;overflow:hidden;position:relative;touch-action:none}
    .cell img{width:100%;height:100%;object-fit:cover;display:block;user-select:none}
    .start-overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
    .start-btn{background:linear-gradient(90deg,#ff7ab6,#7b61ff);border:none;padding:12px 22px;border-radius:999px;font-size:1.6rem;color:#fff;box-shadow:0 8px 30px rgba(123,97,255,0.25)}
    .selected{outline:3px solid rgba(255,255,255,0.18);transform:scale(1.04)}
    .pop{animation:pop .45s cubic-bezier(.2,.9,.3,1)}
    @keyframes pop{0%{transform:scale(1)}50%{transform:scale(1.25);filter:brightness(1.25)}100%{transform:scale(1);filter:brightness(1)}}
    .fade-out{animation:fadeout .38s forwards}
    @keyframes fadeout{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.3)}}
    .floating{transition:transform 420ms cubic-bezier(.2,.8,.3,1)}
    .scorebox{font-weight:700}
    .small{font-size:0.85rem;opacity:0.9}
    .footer{margin-top:2vmin;text-align:center;opacity:0.85}
    /* make large tappable area on mobile */
    button{touch-action:manipulation}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="ui">
      <div class="header">
        <div class="panel small">Score: <span id="score" class="scorebox">0</span></div>
        <div class="panel small">Time: <span id="time">60</span>s</div>
        <div class="panel small">Combo: <span id="combo">x1.0</span></div>
      </div>

      <div id="boardWrap" style="position:relative">
        <div id="board" class="board"></div>
        <div id="overlay" class="start-overlay"><button id="startBtn" class="start-btn">START</button></div>
      </div>

      <div class="footer small">Match-3, 1 minute high-score. Tap tiles to select and swap adjacent ones. Good luck!</div>
    </div>
  </div>

  <audio id="sndStart" src="c.mp3" preload="auto"></audio>
  <audio id="sndSwap" src="c.mp3" preload="auto"></audio>
  <audio id="sndClear" src="b.mp3" preload="auto"></audio>

  <script>
  // Config
  const ROWS = 8; const COLS = 8; const TILE_TYPES = 6; const GAME_TIME = 60;
  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const timeEl  = document.getElementById('time');
  const comboEl = document.getElementById('combo');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const sndStart = document.getElementById('sndStart');
  const sndSwap  = document.getElementById('sndSwap');
  const sndClear = document.getElementById('sndClear');

  let board = new Array(ROWS*COLS).fill(0);
  let selected = -1;
  let running = false;
  let score = 0;
  let timeLeft = GAME_TIME;
  let timerId = null;
  let combo = 1.0;
  let processing = false;

  function idx(r,c){return r*COLS+c}
  function rc(i){return [Math.floor(i/COLS), i%COLS]}

  function randInt(min,max){return Math.floor(Math.random()*(max-min+1))+min}

  // generate initial board with no immediate matches
  function generateBoard(){
    const b=new Array(ROWS*COLS).fill(0);
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        let attempts=0;
        while(true){
          const t = randInt(1,TILE_TYPES);
          b[idx(r,c)]=t;
          let bad=false;
          if(c>=2 && b[idx(r,c-1)]===t && b[idx(r,c-2)]===t) bad=true;
          if(r>=2 && b[idx(r-1,c)]===t && b[idx(r-2,c)]===t) bad=true;
          if(!bad) break;
          attempts++; if(attempts>30) break;
        }
      }
    }
    return b;
  }

  function renderBoard(prevBoard){
    // prevBoard optional for simple falling animation detection
    boardEl.innerHTML='';
    for(let i=0;i<board.length;i++){
      const cell = document.createElement('div');
      cell.className='cell';
      cell.dataset.i=i;
      const img = document.createElement('img');
      img.draggable=false;
      img.src = `tile${board[i]}.png`;
      cell.appendChild(img);
      // attach events
      cell.addEventListener('pointerdown', onTap);
      // prepare animation: if prevBoard provided and tile came from above -> floating transform
      if(prevBoard){
        const prev = prevBoard[i];
        if(prev !== board[i]){
          // new tile: start slightly above and drop
          img.style.transform='translateY(-120%)';
          img.classList.add('floating');
          requestAnimationFrame(()=>{
            img.style.transform='translateY(0)';
          });
        }
      }
      boardEl.appendChild(cell);
    }
  }

  function findMatches(b){
    const toClear = new Set();
    // horizontal
    for(let r=0;r<ROWS;r++){
      let runType=null, runStart=0, runLen=0;
      for(let c=0;c<COLS;c++){
        const t=b[idx(r,c)];
        if(t===runType) runLen++; else {
          if(runType && runLen>=3) for(let k=0;k<runLen;k++) toClear.add(idx(r,runStart+k));
          runType=t; runStart=c; runLen=1;
        }
      }
      if(runType && runLen>=3) for(let k=0;k<runLen;k++) toClear.add(idx(r,runStart+k));
    }
    // vertical
    for(let c=0;c<COLS;c++){
      let runType=null, runStart=0, runLen=0;
      for(let r=0;r<ROWS;r++){
        const t=b[idx(r,c)];
        if(t===runType) runLen++; else {
          if(runType && runLen>=3) for(let k=0;k<runLen;k++) toClear.add(idx(runStart+k,c));
          runType=t; runStart=r; runLen=1;
        }
      }
      if(runType && runLen>=3) for(let k=0;k<runLen;k++) toClear.add(idx(runStart+k,c));
    }
    return Array.from(toClear).sort((a,b)=>a-b);
  }

  function collapseBoard(b){
    const nb = b.slice();
    for(let c=0;c<COLS;c++){
      const col=[];
      for(let r=0;r<ROWS;r++) if(nb[idx(r,c)]!==0) col.push(nb[idx(r,c)]);
      const missing = ROWS - col.length;
      const newTiles = Array.from({length:missing},()=>randInt(1,TILE_TYPES));
      const newCol = newTiles.concat(col);
      for(let r=0;r<ROWS;r++) nb[idx(r,c)] = newCol[r];
    }
    return nb;
  }

  // play clear effect visually and sound
  function playClearVisual(indices){
    // add fade-out class to matching images
    indices.forEach(i=>{
      const cell = boardEl.querySelector(`.cell[data-i='${i}']`);
      if(cell){
        const img = cell.querySelector('img');
        img.classList.add('fade-out');
      }
    });
    // sound
    try{ sndClear.currentTime=0; sndClear.play(); }catch(e){}
  }

  async function handleSwap(i1,i2){
    if(processing || !running) return;
    processing=true;
    sndSwap.play().catch(()=>{});
    const newBoard = board.slice();
    [newBoard[i1], newBoard[i2]] = [newBoard[i2], newBoard[i1]];
    board = newBoard; renderBoard();
    // check matches
    let m = findMatches(board);
    if(m.length===0){
      // invalid swap -> swap back
      await delay(260);
      [board[i1], board[i2]] = [board[i2], board[i1]];
      renderBoard();
      processing=false; return;
    }
    // cascade
    let chain=0;
    while(true){
      m = findMatches(board);
      if(m.length===0) break;
      chain++;
      playClearVisual(m);
      // scoring
      const base = m.length * 100;
      const gained = Math.floor(base * (1 + 0.5*(chain-1)) * (1 + (combo-1)*0.2));
      score += gained; scoreEl.textContent = score;

      // clear
      m.forEach(i=> board[i]=0);
      await delay(380); // wait for fade
      const prev = board.slice();
      board = collapseBoard(board);
      // when collapse fills with new tiles, we want falling animation: render with prev
      renderBoard(prev);
      // increase combo slightly for continuous chain
      combo = Math.min(10, combo + 0.5);
      comboEl.textContent = 'x' + combo.toFixed(1);
      await delay(480);
    }
    // reset combo after short delay
    setTimeout(()=>{combo=1.0; comboEl.textContent='x1.0';}, 600);
    processing=false;
  }

  function delay(ms){return new Promise(res=>setTimeout(res,ms))}

  function onTap(e){
    if(!running) return;
    const i = Number(this.dataset.i);
    if(selected===-1){ selected = i; highlight(i); return; }
    if(selected===i){ selected=-1; clearHighlight(); return; }
    const [r1,c1]=rc(selected); const [r2,c2]=rc(i);
    if(Math.abs(r1-r2)+Math.abs(c1-c2)!==1){ selected = i; clearHighlight(); highlight(i); return; }
    clearHighlight(); handleSwap(selected,i); selected=-1;
  }

  function highlight(i){
    const cell = boardEl.querySelector(`.cell[data-i='${i}']`);
    if(cell) cell.classList.add('selected');
  }
  function clearHighlight(){
    const prev = boardEl.querySelector('.selected'); if(prev) prev.classList.remove('selected');
  }

  function startGame(){
    score=0; scoreEl.textContent=0;
    combo=1; comboEl.textContent='x1.0';
    board = generateBoard(); renderBoard();
    running=true; timeLeft=GAME_TIME; timeEl.textContent=timeLeft;
    overlay.style.display='none'; sndStart.play().catch(()=>{});
    timerId = setInterval(()=>{
      timeLeft--; timeEl.textContent = timeLeft;
      if(timeLeft<=0){ clearInterval(timerId); running=false; overlay.style.display='flex'; overlay.querySelector('button').textContent='RESTART'; }
    },1000);
  }

  // attach start
  startBtn.addEventListener('click', startGame);

  // initial render
  board = generateBoard(); renderBoard();

  // prevent context menu on long press
  document.addEventListener('contextmenu', e=>e.preventDefault());

  // optional: expose reset for debugging
  window.__match3 = { regen: ()=>{board=generateBoard(); renderBoard();} };
  </script>


<!-- Optional backend: server.py (Flask) for serving files and a simple score leaderboard API -->

<!--
Save this as server.py and run `python3 server.py`.
Put index.html, tile images, and mp3 files in a `static` folder next to server.py.
This is optional â€” static hosting (GitHub Pages / static webserver) is sufficient for the game.
-->

<!-- server.py -->
# ------------------------------------
# from flask import Flask, send_from_directory, request, jsonify
# import os
#
# app = Flask(__name__, static_folder='static')
#
# SCORES_FILE = 'scores.json'
#
# def load_scores():
#     import json
#     if not os.path.exists(SCORES_FILE):
#         return []
#     with open(SCORES_FILE,'r',encoding='utf-8') as f:
#         return json.load(f)
#
# def save_scores(scores):
#     import json
#     with open(SCORES_FILE,'w',encoding='utf-8') as f:
#         json.dump(scores,f,ensure_ascii=False,indent=2)
#
# @app.route('/')
# def root():
#     return send_from_directory('static','index.html')
#
# @app.route('/<path:filename>')
# def static_files(filename):
#     return send_from_directory('static', filename)
#
# @app.route('/api/score', methods=['POST'])
# def post_score():
#     data = request.get_json() or {}
#     name = data.get('name','anon')[:24]
#     score = int(data.get('score',0))
#     scores = load_scores()
#     scores.append({'name':name,'score':score,'ts':int(__import__('time').time())})
#     scores = sorted(scores, key=lambda x: x['score'], reverse=True)[:100]
#     save_scores(scores)
#     return jsonify({'ok':True})
#
# @app.route('/api/score', methods=['GET'])
# def get_scores():
#     scores = load_scores()
#     return jsonify(scores[:20])
#
# if __name__ == '__main__':
#     app.run(host='0.0.0.0', port=8000, debug=True)
# ------------------------------------
