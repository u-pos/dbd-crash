import React, { useEffect, useState, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";

// Match-3 single-file React component
// Place tile images (tile1.png ... tile6.png) and sounds (c.mp3, b.mp3) in your public folder.
// Drop this file into a React app (e.g., created with create-react-app) and render <Match3Game />.

const ROWS = 8;
const COLS = 8;
const TILE_TYPES = 6;
const GAME_TIME = 60; // seconds

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function index(r, c) {
  return r * COLS + c;
}

function coords(i) {
  return [Math.floor(i / COLS), i % COLS];
}

// Generate a board that has no immediate matches (no 3+ in a row/col)
function generateBoard() {
  const board = new Array(ROWS * COLS).fill(0);
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      let attempts = 0;
      while (true) {
        const t = randInt(1, TILE_TYPES);
        board[index(r, c)] = t;
        // check left and up to avoid creating 3-in-a-row
        let bad = false;
        if (c >= 2 && board[index(r, c - 1)] === t && board[index(r, c - 2)] === t) bad = true;
        if (r >= 2 && board[index(r - 1, c)] === t && board[index(r - 2, c)] === t) bad = true;
        if (!bad) break;
        attempts++;
        if (attempts > 20) break; // fail-safe
      }
    }
  }
  return board;
}

// Find matches (returns array of indices that should be cleared)
function findMatches(board) {
  const toClear = new Set();
  // horizontal
  for (let r = 0; r < ROWS; r++) {
    let runType = null;
    let runStart = 0;
    let runLen = 0;
    for (let c = 0; c < COLS; c++) {
      const t = board[index(r, c)];
      if (t === runType) {
        runLen++;
      } else {
        if (runType && runLen >= 3) {
          for (let k = 0; k < runLen; k++) toClear.add(index(r, runStart + k));
        }
        runType = t;
        runStart = c;
        runLen = 1;
      }
    }
    if (runType && runLen >= 3) for (let k = 0; k < runLen; k++) toClear.add(index(r, runStart + k));
  }
  // vertical
  for (let c = 0; c < COLS; c++) {
    let runType = null;
    let runStart = 0;
    let runLen = 0;
    for (let r = 0; r < ROWS; r++) {
      const t = board[index(r, c)];
      if (t === runType) {
        runLen++;
      } else {
        if (runType && runLen >= 3) {
          for (let k = 0; k < runLen; k++) toClear.add(index(runStart + k, c));
        }
        runType = t;
        runStart = r;
        runLen = 1;
      }
    }
    if (runType && runLen >= 3) for (let k = 0; k < runLen; k++) toClear.add(index(runStart + k, c));
  }
  return Array.from(toClear).sort((a, b) => a - b);
}

export default function Match3Game() {
  const [board, setBoard] = useState(generateBoard());
  const [selected, setSelected] = useState(null);
  const [score, setScore] = useState(0);
  const [timeLeft, setTimeLeft] = useState(GAME_TIME);
  const [running, setRunning] = useState(false);
  const [fallingMap, setFallingMap] = useState({}); // index -> offsetY for animation
  const [comboMultiplier, setComboMultiplier] = useState(1);
  const [isProcessing, setIsProcessing] = useState(false);
  const startAudioRef = useRef(null);
  const swapAudioRef = useRef(null);
  const clearAudioRef = useRef(null);
  const timerRef = useRef(null);
  const gravityRef = useRef(0.0025); // px / ms^2 relative factor

  useEffect(() => {
    startAudioRef.current = new Audio("/c.mp3");
    swapAudioRef.current = new Audio("/c.mp3");
    clearAudioRef.current = new Audio("/b.mp3");
  }, []);

  useEffect(() => {
    if (running) {
      timerRef.current = setInterval(() => {
        setTimeLeft((t) => {
          if (t <= 1) {
            clearInterval(timerRef.current);
            setRunning(false);
            return 0;
          }
          return t - 1;
        });
      }, 1000);
    } else {
      clearInterval(timerRef.current);
    }
    return () => clearInterval(timerRef.current);
  }, [running]);

  // Helper to swap two indices and return new board
  function swapIndices(b, i1, i2) {
    const nb = b.slice();
    const tmp = nb[i1];
    nb[i1] = nb[i2];
    nb[i2] = tmp;
    return nb;
  }

  // Try to make a swap initiated by user
  async function trySwap(i) {
    if (isProcessing || !running) return;
    if (selected === null) {
      setSelected(i);
      return;
    }
    if (selected === i) {
      setSelected(null);
      return;
    }
    const [r1, c1] = coords(selected);
    const [r2, c2] = coords(i);
    const dr = Math.abs(r1 - r2);
    const dc = Math.abs(c1 - c2);
    // only adjacent
    if (dr + dc !== 1) {
      setSelected(i);
      return;
    }

    swapAudioRef.current?.play();
    setIsProcessing(true);
    const newBoard = swapIndices(board, selected, i);
    setBoard(newBoard);

    // check if swap created matches
    const matches = findMatches(newBoard);
    if (matches.length === 0) {
      // invalid swap -> swap back after short delay
      await new Promise((res) => setTimeout(res, 300));
      setBoard(swapIndices(newBoard, selected, i));
      setSelected(null);
      setIsProcessing(false);
      return;
    }

    // valid swap, handle matches & cascades
    let runningBoard = newBoard;
    let chain = 0;
    while (true) {
      const m = findMatches(runningBoard);
      if (m.length === 0) break;
      chain++;
      playClearEffect(m);
      // scoring: base 100 per tile * comboMultiplier * chain factor
      const base = m.length * 100;
      const gained = Math.floor(base * (1 + 0.5 * (chain - 1)) * (1 + (comboMultiplier - 1) * 0.2));
      setScore((s) => s + gained);
      // clear
      for (const idx of m) runningBoard[idx] = 0;
      // simulate gravity / drop
      runningBoard = collapseBoard(runningBoard);
      setBoard(runningBoard);
      // increase multiplier for next chain in same cascade
      setComboMultiplier((m) => Math.min(10, m + 0.5));
      await new Promise((res) => setTimeout(res, 430)); // wait to show effect
    }
    // reset combo multiplier slowly
    setTimeout(() => setComboMultiplier(1), 500);
    setSelected(null);
    setIsProcessing(false);
  }

  function playClearEffect(indices) {
    // play sound
    clearAudioRef.current?.currentTime && (clearAudioRef.current.currentTime = 0);
    clearAudioRef.current?.play();
    // For rich visual effect we rely on Framer Motion with scaling/fade
    // Additionally we compute falling offsets for the above tiles
    const updates = {};
    indices.forEach((i) => (updates[i] = 0));
    setFallingMap((m) => ({ ...m, ...updates }));
  }

  // Collapse the board after clears: for each column, drop tiles down and fill from top with new tiles
  function collapseBoard(b) {
    const nb = b.slice();
    for (let c = 0; c < COLS; c++) {
      const col = [];
      for (let r = 0; r < ROWS; r++) {
        const v = nb[index(r, c)];
        if (v !== 0) col.push(v);
      }
      const missing = ROWS - col.length;
      const newTiles = Array.from({ length: missing }, () => randInt(1, TILE_TYPES));
      const newCol = newTiles.concat(col); // new tiles at top
      for (let r = 0; r < ROWS; r++) nb[index(r, c)] = newCol[r];
    }
    return nb;
  }

  function startGame() {
    setScore(0);
    setTimeLeft(GAME_TIME);
    setBoard(generateBoard());
    setRunning(true);
    startAudioRef.current?.play();
  }

  // visual helpers
  function tileImageForType(t) {
    return `/tile${t}.png`;
  }

  // render grid
  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-900 via-purple-900 to-pink-900 p-6">
      <div className="w-[760px] max-w-full bg-white/5 rounded-2xl p-6 shadow-2xl backdrop-blur-lg border border-white/10">
        <div className="flex justify-between items-center mb-4">
          <div className="text-white text-lg">Score: <span className="font-mono">{score}</span></div>
          <div className="text-white text-lg">Time: <span className="font-mono">{timeLeft}s</span></div>
          <div className="text-white text-lg">Combo: <span className="font-mono">x{comboMultiplier.toFixed(1)}</span></div>
        </div>

        <div className="relative bg-white/6 rounded-xl p-4 flex justify-center">
          {/* Game Board */}
          <div className="relative">
            <div
              className="grid"
              style={{
                gridTemplateColumns: `repeat(${COLS}, 64px)`,
                gridTemplateRows: `repeat(${ROWS}, 64px)`
              }}
            >
              {board.map((t, i) => {
                const [r, c] = coords(i);
                const isSelected = selected === i;
                const img = t > 0 ? tileImageForType(t) : null;
                return (
                  <div
                    key={i}
                    className="w-[64px] h-[64px] p-1"
                    onMouseDown={() => trySwap(i)}
                    onTouchStart={() => trySwap(i)}
                  >
                    <AnimatePresence>
                      {img && (
                        <motion.div
                          layout
                          initial={{ scale: 0.9, opacity: 0 }}
                          animate={{ scale: isSelected ? 1.08 : 1, opacity: 1 }}
                          exit={{ scale: 0.1, opacity: 0 }}
                          transition={{ type: "spring", stiffness: 700, damping: 24 }}
                          className={`w-full h-full rounded-lg overflow-hidden shadow-md relative border border-white/10`}
                          style={{ background: "linear-gradient(180deg, rgba(255,255,255,0.03), transparent)" }}
                        >
                          <motion.img
                            src={img}
                            alt={`tile-${t}`}
                            draggable={false}
                            style={{ width: "100%", height: "100%", objectFit: "cover" }}
                          />
                          {/* bright pop effect for matches (brief) */}
                        </motion.div>
                      )}
                      {!img && (
                        <motion.div
                          initial={{ opacity: 0 }}
                          animate={{ opacity: 0 }}
                          exit={{ opacity: 0 }}
                        />
                      )}
                    </AnimatePresence>
                  </div>
                );
              })}
            </div>

            {/* Start overlay */}
            {!running && (
              <div className="absolute inset-0 flex items-center justify-center">
                <button
                  onClick={startGame}
                  className="bg-gradient-to-br from-rose-400 to-indigo-500 text-white px-8 py-4 rounded-3xl text-2xl shadow-2xl transform hover:scale-105 active:scale-95"
                >
                  START
                </button>
              </div>
            )}
          </div>
        </div>

        <div className="mt-4 text-sm text-white/80">Instructions: Match 3+ tiles. Swap adjacent tiles. 1-minute high-score mode. Good luck!</div>
      </div>
    </div>
  );
}
