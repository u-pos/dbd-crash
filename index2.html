<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>Match-3 Mobile Swipe</title>
<style>
:root { --cols:8; --rows:8; --tile-size:11vw; }
html,body {
  margin:0; padding:0; width:100%; height:100%;
  overflow:hidden; background:#111;
  font-family:sans-serif;
}
.wrap { width:100%; height:100%; display:flex; flex-direction:column; align-items:center; }
.header { display:flex; justify-content:space-between; align-items:center; margin-bottom:1.5vw; font-size:3.6vw; font-weight:600; }
.panel { background:rgba(255,255,255,0.04); padding:0.8vw 1.5vw; border-radius:12px; min-width:28vw; text-align:center; }

.board {
  background:linear-gradient(180deg,rgba(255,255,255,0.03),transparent);
  padding:6px; border-radius:10px;
  display:grid; grid-template-columns:repeat(var(--cols),var(--tile-size)); gap:4px;
  position:relative;
}

.cell {width:var(--tile-size);height:var(--tile-size);border-radius:8px;background:#111a2a;display:flex;align-items:center;justify-content:center;}
.cell img {width:100%;height:100%;object-fit:cover;pointer-events:none;transform-origin:center center;}

@keyframes vanish {0%{transform:scale(1);opacity:1;}50%{transform:scale(1.25);opacity:0.6;}100%{transform:scale(0);opacity:0;}}
.vanish {animation:vanish 180ms ease-out forwards;}

#combo {
  position:absolute;
  top:-10vw; left:50%;
  transform:translateX(-50%);
  background:rgba(0,0,0,0.4);
  padding:2px 10px;
  border-radius:8px;
  font-weight:900;
  font-size:7vw;
  color:#ffde59;
  pointer-events:none;
  transform-origin:center;
  z-index:5;
}
#combo .combo-num { font-size:9vw; }
@keyframes comboPop {0%{transform:scale(1);}20%{transform:scale(1.3);}60%{transform:scale(0.95);}100%{transform:scale(1);}}
.combo-pop { animation: comboPop 0.35s ease-out; }

.start-overlay,#gameOverOverlay {
  position:absolute;inset:0;
  display:flex;align-items:center;justify-content:center;
  background:rgba(0,0,0,0.35);border-radius:10px;flex-direction:column;z-index:10;
}
.start-btn {background:linear-gradient(90deg,#ff7ab6,#7b61ff);border:none;padding:14px 26px;border-radius:999px;font-size:1.8rem;color:#fff;cursor:pointer;}
#gameOverOverlay {font-size:10vw;font-weight:900;color:#fff;flex-wrap:wrap;gap:1vw;text-align:center;}
.bottom-buttons {display:flex;gap:1.5rem;margin-top:0.8rem;}
.icon-btn {background:none;border:none;font-size:2.8rem;color:white;cursor:pointer;}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="panel">Score: <span id="score">0</span></div>
    <div class="panel">ÊÆã„Çä <span id="time">60</span> Áßí</div>
  </div>
  <div id="boardWrap" style="position:relative;">
    <div id="board" class="board"></div>
    <div id="overlay" class="start-overlay">
      <button id="startBtn" class="start-btn">START</button>
    </div>
    <div id="pauseOverlay" class="pause-overlay">
      <div id="pauseText">‰∏ÄÊôÇÂÅúÊ≠¢‰∏≠</div>
      <button id="resumeBtn" class="start-btn">‚ñ∂</button>
    </div>
    <div id="gameOverOverlay" style="display:none;"></div>
  </div>

  <div class="bottom-buttons">
    <button id="muteBtn" class="icon-btn">üîá</button>
    <button id="pauseBtn" class="icon-btn">‚è∏</button>
  </div>
</div>

<audio id="sndStart" src="s.mp3" preload="auto"></audio>
<audio id="sndClear" src="cc.mp3" preload="auto"></audio>
<audio id="bgm" src="bgm2.mp3" preload="auto" loop></audio>

<script>
const ROWS=8,COLS=8,TILE_TYPES=6,GAME_TIME=60;
let board=[],running=false,score=0,timeLeft=GAME_TIME,timerId,combo=1,processing=false;
const boardEl=document.getElementById('board');
const scoreEl=document.getElementById('score');
const timeEl=document.getElementById('time');
const sndStart=document.getElementById('sndStart');
const sndClear=document.getElementById('sndClear');
const bgm=document.getElementById('bgm');
bgm.volume=0.2;

function idx(r,c){return r*COLS+c}
function rc(i){return [Math.floor(i/COLS),i%COLS]}
function randInt(min,max){return Math.floor(Math.random()*(max-min+1))+min}

function generateBoard(){
  const b=new Array(ROWS*COLS).fill(0);
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      while(true){
        const t=randInt(1,TILE_TYPES);
        b[idx(r,c)]=t;
        if(!(c>=2 && b[idx(r,c-1)]===t && b[idx(r,c-2)]===t) && 
           !(r>=2 && b[idx(r-1,c)]===t && b[idx(r-2,c)]===t)) break;
      }
    }
  }
  return b;
}

function findMatches(b){
  const clear=new Set();
  for(let r=0;r<ROWS;r++){
    let runT=null, runS=0, runL=0;
    for(let c=0;c<COLS;c++){
      const t=b[idx(r,c)];
      if(t===runT) runL++;
      else { if(runT && runL>=3) for(let k=0;k<runL;k++) clear.add(idx(r,runS+k));
             runT=t; runS=c; runL=1;}
    }
    if(runT && runL>=3) for(let k=0;k<runL;k++) clear.add(idx(r,runS+k));
  }
  for(let c=0;c<COLS;c++){
    let runT=null, runS=0, runL=0;
    for(let r=0;r<ROWS;r++){
      const t=b[idx(r,c)];
      if(t===runT) runL++;
      else { if(runT && runL>=3) for(let k=0;k<runL;k++) clear.add(idx(runS+k,c));
             runT=t; runS=r; runL=1;}
    }
    if(runT && runL>=3) for(let k=0;k<runL;k++) clear.add(idx(runS+k,c));
  }
  return Array.from(clear).sort((a,b)=>a-b);
}

function collapseBoard(b){
  const nb=b.slice();
  for(let c=0;c<COLS;c++){
    let emptyRow=ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(nb[idx(r,c)]!==0){
        nb[idx(emptyRow,c)]=nb[idx(r,c)];
        if(emptyRow!==r) nb[idx(r,c)]=0;
        emptyRow--;
      }
    }
    for(let r=emptyRow;r>=0;r--){
      nb[idx(r,c)]=randInt(1,TILE_TYPES);
    }
  }
  return nb;
}

function swapTiles(b,i1,i2){const nb=b.slice();[nb[i1],nb[i2]]=[nb[i2],nb[i1]];return nb;}
function scoreForMatch(count){
  return count===3?100: count===4?300: count===5?500: 500+(count-5)*100;
}

function renderBoard(prevBoard){
  boardEl.innerHTML='';
  for(let i=0;i<board.length;i++){
    const t=board[i];
    const cell=document.createElement('div');
    cell.className='cell';
    cell.dataset.i=i;
    if(t>0){
      const img=document.createElement('img');
      img.src=`tile${t}.png`;
      if(prevBoard && prevBoard[i]===0){
        img.style.opacity='0'; img.style.transform='translateY(-120%)';
        requestAnimationFrame(()=>{ img.style.transition='transform 0.4s ease, opacity 0.4s'; img.style.transform='translateY(0)'; img.style.opacity='1';});
      }
      cell.appendChild(img);
    }
    boardEl.appendChild(cell);
  }
  const comboBox=document.createElement('div');
  comboBox.id='combo';
  if(combo>1) comboBox.innerHTML=`<span class="combo-num">${combo}</span>„Ç≥„É≥„ÉúÔºÅ`;
  boardEl.appendChild(comboBox);
}

function waitForAnimations(elems,timeout=800){
  return new Promise(res=>{
    if(!elems.length) return res();
    let rem=elems.length;
    elems.forEach(el=>{
      el.addEventListener('animationend',()=>{if(--rem<=0)res();},{once:true});
      setTimeout(()=>{if(--rem<=0)res();},timeout);
    });
  });
}

function startGame(){
  bgm.currentTime=0; bgm.play().catch(()=>{});
  board=generateBoard(); score=0; timeLeft=GAME_TIME; combo=1; processing=false;
  running=true; overlay.style.display='none'; gameOverOverlay.style.display='none';
  updateUI(); renderBoard();
  sndStart.currentTime=0; sndStart.play();
  timerId=setInterval(()=>{ timeLeft--; if(timeLeft<=0){ clearInterval(timerId); running=false; showGameOver(); } updateUI(); },1000);
}

function updateUI(){
  scoreEl.textContent=score; timeEl.textContent=timeLeft;
  const comboBox=document.getElementById('combo');
  if(comboBox) comboBox.innerHTML=combo>1?`<span class="combo-num">${combo}</span>„Ç≥„É≥„ÉúÔºÅ`:'';
}

function showGameOver(){
  bgm.pause(); gameOverOverlay.style.display='flex';
  gameOverOverlay.innerHTML=`<div>ÊúÄÁµÇ„Çπ„Ç≥„Ç¢</div><div style="font-size:15vw;font-weight:900;">${score}</div><button id="restartBtn" class="start-btn">RESTART</button>`;
  document.getElementById('restartBtn').onclick=()=>{startGame(); gameOverOverlay.style.display='none';};
}

function isAdjacent(i1,i2){const [r1,c1]=rc(i1),[r2,c2]=rc(i2);return Math.abs(r1-r2)+Math.abs(c1-c2)===1;}

function playClearSound(rate){
  const snd=new Audio(sndClear.src);
  snd.playbackRate=rate;
  snd.play();
}

async function playerMove(i1,i2){
  if(!running||processing) return;
  if(!isAdjacent(i1,i2)) return;
  processing=true;
  const newB=swapTiles(board,i1,i2);
  if(findMatches(newB).length===0){
    renderSwapAnimation(i1,i2,false); await new Promise(r=>setTimeout(r,350)); processing=false; return;
  }
  renderSwapAnimation(i1,i2,true);
  board=newB; let chain=0;
  while(true){
    const matches=findMatches(board);
    if(!matches.length) break;
    chain++;
    const rate=Math.min(1.0+Math.max(0,chain-1)*0.1,2.0);
    playClearSound(rate);
    const comboBox=document.getElementById('combo');
    if(comboBox){ comboBox.classList.remove('combo-pop'); void comboBox.offsetWidth; comboBox.classList.add('combo-pop'); }

    const groups=groupMatches(board,matches);
    let gained=0; for(let g of groups){gained+=scoreForMatch(g.length)*Math.min(chain,10);}
    score+=gained; combo=Math.min(10,chain);

    const imgEls=matches.map(i=>boardEl.querySelector(`.cell[data-i='${i}'] img`)).filter(Boolean);
    imgEls.forEach(img=>{img.classList.remove('vanish'); void img.offsetWidth; img.classList.add('vanish');});
    await waitForAnimations(imgEls,600);
    matches.forEach(i=>board[i]=0);

    const oldRects=[...boardEl.children].map(el=>el.getBoundingClientRect());
    board=collapseBoard(board); renderBoard(board);
    const newRects=[...boardEl.children].map(el=>el.getBoundingClientRect());
    const basePerTile=120;
    [...boardEl.children].forEach((cell,i)=>{
      const old=oldRects[i], neu=newRects[i];
      if(!old||!neu) return;
      const dx=old.left-neu.left, dy=old.top-neu.top;
      const tilesMoved=Math.round(Math.abs(dy)/neu.height);
      const duration=Math.max(100,basePerTile*tilesMoved);
      if(dx||dy){
        cell.style.transform=`translate(${dx}px,${dy}px)`;
        cell.style.transition=`transform ${duration}ms cubic-bezier(.25,.8,.5,1)`;
        requestAnimationFrame(()=>{cell.style.transform='';});
      }
    });
    const maxTiles=Math.max(...newRects.map((_,i)=>Math.round(Math.abs(oldRects[i].top-newRects[i].top)/newRects[i].height)));
    await new Promise(r=>setTimeout(r,basePerTile*maxTiles+80));
    [...boardEl.children].forEach(cell=>{cell.style.transition=''; cell.style.transform='';});
  }
  updateUI(); processing=false;
}

function renderSwapAnimation(i1,i2,success){
  const cells=boardEl.children, cell1=cells[i1], cell2=cells[i2];
  if(!cell1||!cell2) return;
  const pos1=cell1.getBoundingClientRect(), pos2=cell2.getBoundingClientRect();
  const dx=pos2.left-pos1.left, dy=pos2.top-pos1.top;
  cell1.style.transition='transform 300ms ease'; cell2.style.transition='transform 300ms ease';
  cell1.style.transform=`translate(${dx}px,${dy}px)`; cell2.style.transform=`translate(${-dx}px,${-dy}px)`;
  setTimeout(()=>{cell1.style.transition='';cell2.style.transition='';cell1.style.transform='';cell2.style.transform=''; if(!success) renderBoard();},300);
}

function groupMatches(boardArr,indices){
  const adj={}; indices.forEach(i=>adj[i]=[]);
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  indices.forEach(i=>{
    const [r,c]=rc(i);
    dirs.forEach(([dr,dc])=>{
      const ni=idx(r+dr,c+dc);
      if(indices.includes(ni)) adj[i].push(ni);
    });
  });
  const visited=new Set(), groups=[];
  indices.forEach(i=>{
    if(visited.has(i)) return;
    const q=[i], g=[];
    while(q.length){
      const cur=q.shift(); if(visited.has(cur)) continue;
      visited.add(cur); g.push(cur);
      adj[cur].forEach(n=>{if(!visited.has(n)) q.push(n);});
    }
    groups.push(g);
  });
  return groups;
}

let touchStartIndex=null,startX=0,startY=0;
boardEl.addEventListener('touchstart',e=>{
  if(!running||processing) return;
  const t=e.target.closest('.cell'); if(!t) return;
  touchStartIndex=Number(t.dataset.i);
  startX=e.touches[0].clientX; startY=e.touches[0].clientY;
},{passive:false});
boardEl.addEventListener('touchend',e=>{
  if(touchStartIndex===null||!running||processing){ touchStartIndex=null; return; }
  const dx=e.changedTouches[0].clientX-startX, dy=e.changedTouches[0].clientY-startY;
  if(Math.max(Math.abs(dx),Math.abs(dy))<20){ touchStartIndex=null; return; }
  const [r,c]=rc(touchStartIndex);
  let tr=r, tc=c;
  if(Math.abs(dx)>Math.abs(dy)) tc+=(dx>0?1:-1); else tr+=(dy>0?1:-1);
  if(tr<0||tr>=ROWS||tc<0||tc>=COLS){ touchStartIndex=null; return; }
  playerMove(touchStartIndex,idx(tr,tc)); touchStartIndex=null;
},{passive:false});

function renderBoardInitial(){board=generateBoard(); renderBoard();}
renderBoardInitial(); updateUI();

document.getElementById('startBtn').onclick=startGame;
let muted=false;
document.getElementById('muteBtn').onclick=()=>{
  muted=!muted;
  [bgm,sndStart,sndClear].forEach(s=>s.muted=muted);
};
</script>
</body>
</html>
