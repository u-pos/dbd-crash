<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>Match-3 Mobile Swipe</title>
<style>
:root { --cols:8; --rows:8; --tile-size:11vw; }
html,body {
  margin:0; padding:0; width:100%; height:100%;
  overflow:hidden; overscroll-behavior:none;
  background:#111; color:#fff; font-family:sans-serif;
}
.wrap { width:100%; height:100%; display:flex; flex-direction:column; align-items:center; }
.header { display:flex; justify-content:space-between; align-items:center; margin-bottom:1.5vw; font-size:3.6vw; font-weight:600; }
.panel { background:rgba(255,255,255,0.04); padding:0.8vw 1.5vw; border-radius:12px; min-width:28vw; text-align:center; }
#combo {color:#ffde59;font-weight:900;font-size:3.5vw;}
.board {background:linear-gradient(180deg,rgba(255,255,255,0.03),transparent);padding:6px;border-radius:10px;
display:grid;grid-template-columns:repeat(var(--cols),var(--tile-size));gap:4px;touch-action:none;box-sizing:border-box;}
.cell {width:var(--tile-size);height:var(--tile-size);border-radius:8px;overflow:hidden;background:#111a2a;
display:flex;align-items:center;justify-content:center;}
.cell img {width:100%;height:100%;object-fit:cover;pointer-events:none;}
@keyframes vanish {0%{transform:scale(1);opacity:1;}50%{transform:scale(1.25);opacity:0.6;}100%{transform:scale(0);opacity:0;}}
.vanish {animation:vanish 180ms cubic-bezier(.2,.9,.3,1) forwards;}
.start-overlay,#gameOverOverlay {
  position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
  background:rgba(0,0,0,0.35);border-radius:10px;flex-direction:column;z-index:10;
}
.start-btn {background:linear-gradient(90deg,#ff7ab6,#7b61ff);border:none;
padding:14px 26px;border-radius:999px;font-size:1.8rem;color:#fff;cursor:pointer;}
#gameOverOverlay {font-size:10vw;font-weight:900;flex-wrap:wrap;gap:1vw;text-align:center;}
.bottom-buttons {display:flex;justify-content:center;align-items:center;gap:1.5rem;margin-top:0.8rem;}
.icon-btn {background:none;border:none;font-size:2.8rem;color:white;cursor:pointer;}
.rules-table-fixed {margin-top:0.5rem;font-size:0.75rem;width:100%;}
.rules-table-fixed table {width:100%;color:#fff;border-collapse:collapse;text-align:center;}
.rules-table-fixed th,.rules-table-fixed td {border-bottom:1px solid #555;padding:0.2rem;}
.rules-table-fixed th {border-bottom:2px solid #ffde59;}
.pause-overlay {position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:black;z-index:20;
flex-direction:column;color:white;font-size:1.5rem;}
/* ランキングオーバーレイ */
#rankingOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 100;
  display: none;
  justify-content: center;
  align-items: center;
}
.ranking-content {
  background: rgba(255,255,255,0.95);
  color: #000;
  padding: 1rem;
  border-radius: 8px;
  width: 80%;
  max-width: 500px;
  display: flex;
  flex-direction: column;
  max-height: 80%;
  overflow-y: auto;
}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="panel">Score: <span id="score">0</span></div>
    <div class="panel">残り <span id="time">60</span> 秒</div>
    <div class="panel"><span id="combo"></span></div>
  </div>
  <div id="boardWrap" style="position:relative;">
    <div id="board" class="board"></div>
    <div id="overlay" class="start-overlay">
      <button id="startBtn" class="start-btn">START</button>
    </div>
    <div id="pauseOverlay" class="pause-overlay">
      <div id="pauseText">一時停止中</div>
      <button id="resumeBtn" class="start-btn">▶</button>
    </div>
    <div id="gameOverOverlay" style="display:none;"></div>
  </div>
  <div class="bottom-buttons">
    <button id="muteBtn" class="icon-btn">🔇</button>
    <button id="pauseBtn" class="icon-btn">⏸</button>
    <button id="rankingBtn" class="icon-btn">🏆</button>
  </div>
  <div class="rules-table-fixed">
    <table>
      <thead><tr><th>得点ルール</th><th>内容</th></tr></thead>
      <tbody>
        <tr><td>3個消し</td><td>100点</td></tr>
        <tr><td>4個消し</td><td>300点</td></tr>
        <tr><td>5個消し</td><td>500点</td></tr>
        <tr>
          <td colspan="2">2コンボ目は得点2倍、3コンボ目は得点3倍。</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<!-- ランキングオーバーレイ -->
<div id="rankingOverlay">
  <div class="ranking-content">
    <button id="closeRanking" class="icon-btn" style="font-size:2rem;align-self:flex-end;">✖</button>
    <h2 style="text-align:center;">🏆 ランキング TOP20 🏆</h2>
    <div id="rankingList" style="font-size:4vw;"></div>
  </div>
</div>

<audio id="sndStart" src="s.mp3" preload="auto"></audio>
<audio id="sndClear" src="cc.mp3" preload="auto"></audio>
<audio id="bgm" src="bgm2.mp3" preload="auto" loop></audio>

<script>
// APIエンドポイント ※URLは自分のサーバーに合わせて修正してください
const API_BASE_URL = 'https://YOUR_DOMAIN/api/';

function escapeHtml(str){
  return str.replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

// ランキング読込
function loadRanking(){
  fetch(API_BASE_URL+'get_scores.php')
    .then(r=>r.json())
    .then(data=>{
      if(data.success){
        let html = '<ol>';
        data.scores.forEach(s => {
          html += `<li>${escapeHtml(s.name)} - ${s.score}</li>`;
        });
        html += '</ol>';
        document.getElementById('rankingList').innerHTML = html;
      }else{
        document.getElementById('rankingList').innerHTML = '<p>取得失敗</p>';
      }
    }).catch(err=>{
      console.error(err);
      document.getElementById('rankingList').innerHTML = '<p>通信エラー</p>';
    });
}

// ランキングボタンイベント
document.getElementById('rankingBtn').addEventListener('click',()=>{
  loadRanking();
  document.getElementById('rankingOverlay').style.display='flex';
});
document.getElementById('closeRanking').addEventListener('click',()=>{
  document.getElementById('rankingOverlay').style.display='none';
});

// --- 通常ゲームロジック（あなたの「正しいコード」部分） ---
const ROWS=8, COLS=8, TILE_TYPES=6, GAME_TIME=60;
let board=[],running=false,score=0,timeLeft=GAME_TIME,timerId,combo=1,processing=false;
const boardEl=document.getElementById('board');
const scoreEl=document.getElementById('score');
const timeEl=document.getElementById('time');
const comboEl=document.getElementById('combo');
const overlay=document.getElementById('overlay');
const gameOverOverlay=document.getElementById('gameOverOverlay');
const sndStart=document.getElementById('sndStart');
const sndClear=document.getElementById('sndClear');
const bgm=document.getElementById('bgm');
bgm.volume=0.2;

function idx(r,c){return r*COLS+c}
function rc(i){return [Math.floor(i/COLS),i%COLS]}
function randInt(min,max){return Math.floor(Math.random()*(max-min+1))+min}
function generateBoard(){
  const b=new Array(ROWS*COLS).fill(0);
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let attempts=0;
      while(true){
        const t=randInt(1,TILE_TYPES);
        b[idx(r,c)]=t;
        let bad=false;
        if(c>=2 && b[idx(r,c-1)]==t && b[idx(r,c-2)]==t) bad=true;
        if(r>=2 && b[idx(r-1,c)]==t && b[idx(r-2,c)]==t) bad=true;
        if(!bad) break;
        attempts++; if(attempts>50) break;
      }
    }
  }
  return b;
}
function findMatches(b){
  const clear=new Set();
  for(let r=0;r<ROWS;r++){
    let runT=null, runS=0, runL=0;
    for(let c=0;c<COLS;c++){
      const t=b[idx(r,c)];
      if(t===runT) runL++;
      else {
        if(runT && runL>=3) for(let k=0;k<runL;k++) clear.add(idx(r,runS+k));
        runT=t; runS=c; runL=1;
      }
    }
    if(runT && runL>=3) for(let k=0;k<runL;k++) clear.add(idx(r,runS+k));
  }
  for(let c=0;c<COLS;c++){
    let runT=null, runS=0, runL=0;
    for(let r=0;r<ROWS;r++){
      const t=b[idx(r,c)];
      if(t===runT) runL++;
      else {
        if(runT && runL>=3) for(let k=0;k<runL;k++) clear.add(idx(runS+k,c));
        runT=t; runS=r; runL=1;
      }
    }
    if(runT && runL>=3) for(let k=0;k<runL;k++) clear.add(idx(runS+k,c));
  }
  return Array.from(clear).sort((a,b)=>a-b);
}
function collapseBoard(b){
  const nb=b.slice();
  for(let c=0;c<COLS;c++){
    let emptyRow=ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(nb[idx(r,c)]!==0){
        nb[idx(emptyRow,c)]=nb[idx(r,c)];
        if(emptyRow!==r) nb[idx(r,c)]=0;
        emptyRow--;
      }
    }
    for(let r=emptyRow;r>=0;r--){
      nb[idx(r,c)]=randInt(1,TILE_TYPES);
    }
  }
  return nb;
}
function swapTiles(b,i1,i2){const nb=b.slice();[nb[i1],nb[i2]]=[nb[i2],nb[i1]];return nb;}
function scoreForMatch(count){
  switch(count){
    case 3:return 100;
    case 4:return 300;
    case 5:return 500;
    default:return 500+(count-5)*100;
  }
}
function renderBoard(prevBoard){
  boardEl.innerHTML='';
  for(let i=0;i<board.length;i++){
    const t=board[i];
    const cell=document.createElement('div');
    cell.className='cell';
    cell.dataset.i=i;
    if(t>0){
      const img=document.createElement('img');
      img.src=`tile${t}.png`;
      if(prevBoard && prevBoard[i]===0){
        img.style.opacity = '0';
        img.style.transform = 'translateY(-120%)';
        requestAnimationFrame(() => {
          img.style.transition = 'transform 0.4s cubic-bezier(.3,.7,.4,1), opacity 0.4s ease';
          img.style.transform = 'translateY(0)';
          img.style.opacity = '1';
        });
      }
      cell.appendChild(img);
    }
    boardEl.appendChild(cell);
  }
}
function waitForAnimations(elements,timeout=800){
  return new Promise(res=>{
    if(!elements || elements.length===0) return res();
    let rem=elements.length;
    elements.forEach(el=>{
      el.addEventListener('animationend',()=>{if(--rem<=0)res();},{once:true});
      setTimeout(()=>{if(--rem<=0)res();},timeout);
    });
  });
}
function startGame(){
  // 全オーバーレイを強制非表示
  overlay.style.display='none';
  gameOverOverlay.style.display='none';
  document.getElementById('rankingOverlay').style.display='none';

  bgm.currentTime=0; bgm.play().catch(()=>{});
  board=generateBoard(); score=0; timeLeft=GAME_TIME; combo=1; processing=false;
  running=true; updateUI(); renderBoard();
  sndStart.currentTime=0; sndStart.play();
  timerId=setInterval(()=>{
    timeLeft--;
    if(timeLeft<=0){ clearInterval(timerId); running=false; showGameOver(); }
    updateUI();
  },1000);
}
function updateUI(){
  scoreEl.textContent=score;
  timeEl.textContent=timeLeft;
  comboEl.textContent=combo>1?`${combo}コンボ！`:'';
}
function showGameOver(){
  bgm.pause();
  fetch(API_BASE_URL+'check_rank.php',{
    method:'POST',
    headers:{'Content-Type':'application/x-www-form-urlencoded'},
    body:new URLSearchParams({score})
  })
  .then(res=>res.json())
  .then(data=>{
    if(data.success && data.entersTop20){
      gameOverOverlay.style.display='flex';
      gameOverOverlay.innerHTML=`
        <div>最終スコア</div>
        <div style="font-size:15vw; font-weight:900;">${score}</div>
        <input type="text" id="playerName" maxlength="50" placeholder="名前を入力" style="font-size:5vw;padding:5px;margin:1rem 0;">
        <button id="saveNameBtn" class="start-btn">登録</button>
      `;
      document.getElementById('saveNameBtn').onclick=()=>{
        const name=document.getElementById('playerName').value.trim();
        if(!name){alert('名前を入力してください');return;}
        fetch(API_BASE_URL+'save_score.php',{
          method:'POST',
          headers:{'Content-Type':'application/x-www-form-urlencoded'},
          body:new URLSearchParams({name,score})
        })
        .then(r=>r.json())
        .then(res=>{
          if(res.success){
            alert('登録しました！');
            loadRanking();
            startGame();
          }else{
            alert(res.error || '登録失敗');
          }
        });
      };
    }else{
      gameOverOverlay.style.display='flex';
      gameOverOverlay.innerHTML=`
        <div>最終スコア</div>
        <div style="font-size:15vw; font-weight:900;">${score}</div>
        <button id="restartBtn" class="start-btn">RESTART</button>
      `;
      document.getElementById('restartBtn').onclick=()=>{
        startGame(); gameOverOverlay.style.display='none';
      };
    }
  });
}
function showGameOver_legacy(){
  // 元のゲームオーバー表示（もう使わない）
}
function groupMatches(boardArr, indices){
  const adj={}; indices.forEach(i=>adj[i]=[]);
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  for(let i of indices){
    const [r,c]=rc(i);
    for(let [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc, ni=idx(nr,nc);
      if(indices.includes(ni)) adj[i].push(ni);
    }
  }
  const visited=new Set(), groups=[];
  for(let i of indices){
    if(visited.has(i)) continue;
    const q=[i], group=[];
    while(q.length){
      const cur=q.shift();
      if(visited.has(cur)) continue;
      visited.add(cur); group.push(cur);
      for(let n of adj[cur]) if(!visited.has(n)) q.push(n);
    }
    groups.push(group);
  }
  return groups;
}
let touchStartIndex=null,startX=0,startY=0;
boardEl.addEventListener('touchstart',e=>{
  if(!running||processing) return;
  const t=e.target.closest('.cell'); if(!t) return;
  touchStartIndex=Number(t.dataset.i);
  startX=e.touches[0].clientX; startY=e.touches[0].clientY;
},{passive:false});
boardEl.addEventListener('touchmove',e=>{
  if(touchStartIndex===null) return;
  e.preventDefault();
},{passive:false});
boardEl.addEventListener('touchend',e=>{
  if(touchStartIndex===null||!running||processing){ touchStartIndex=null; return; }
  const dx=e.changedTouches[0].clientX-startX;
  const dy=e.changedTouches[0].clientY-startY;
  const absDx=Math.abs(dx), absDy=Math.abs(dy);
  if(Math.max(absDx,absDy) < 20){ touchStartIndex=null; return; }
  const [r,c]=rc(touchStartIndex);
  let targetR=r, targetC=c;
  if(absDx>absDy) targetC += (dx>0?1:-1); else targetR += (dy>0?1:-1);
  if(targetR<0||targetR>=ROWS||targetC<0||targetC>=COLS){ touchStartIndex=null; return; }
  const targetIndex = idx(targetR,targetC);
  playerMove(touchStartIndex, targetIndex);
  touchStartIndex=null;
},{passive:false});
async function playerMove(i1,i2){
  if(!running||processing) return;
  if(!isAdjacent(i1,i2)) return;
  processing=true;
  const newB = swapTiles(board,i1,i2);
  const initialMatches = findMatches(newB);
  if(initialMatches.length === 0){
    renderSwapAnimation(i1,i2,false);
    await new Promise(res=>setTimeout(res,350));
    processing=false;
    return;
  }
  renderSwapAnimation(i1,i2,true);
  board = newB;
  sndClear.currentTime = 0; sndClear.play();
  let chain = 0;
  while(true){
    const matches = findMatches(board);
    if(matches.length === 0) break;
    chain++;
    sndClear.currentTime = 0; sndClear.play();
    const groups = groupMatches(board,matches);
    let gained = 0;
    for(let g of groups){
      gained += scoreForMatch(g.length) * Math.min(chain, 10);
    }
    score += gained;
    combo = Math.min(10, chain);
    const imgEls = matches.map(i => {
      const cell = boardEl.querySelector(`.cell[data-i='${i}']`);
      return cell ? cell.querySelector('img') : null;
    }).filter(Boolean);
    imgEls.forEach(img => {
      img.classList.remove('vanish');
      void img.offsetWidth;
      img.classList.add('vanish');
    });
    await waitForAnimations(imgEls, 600);
    matches.forEach(i => board[i] = 0);
    // --- 距離に応じた自然落下 ---
    const oldCells = Array.from(boardEl.children);
    const oldRects = oldCells.map(el => el.getBoundingClientRect());
    const collapsed = collapseBoard(board);
    board = collapsed;
    renderBoard(board); 
    const newCells = Array.from(boardEl.children);
    const newRects = newCells.map(el => el.getBoundingClientRect());
    const basePerTile = 120; 
    newCells.forEach((cell, i) => {
      const old = oldRects[i];
      const neu = newRects[i];
      if (!old || !neu) return;
      const dx = old.left - neu.left;
      const dy = old.top - neu.top;
      const tilesMoved = Math.round(Math.abs(dy) / neu.height);
      const duration = Math.max(100, basePerTile * tilesMoved);
      if (dy!== 0 || dx!== 0) {
        cell.style.transform = `translate(${dx}px, ${dy}px)`;
        cell.style.transition = `transform ${duration}ms cubic-bezier(.25,.8,.5,1)`;
        requestAnimationFrame(() => { cell.style.transform = ''; });
      }
    });
    const maxTiles = Math.max(...newCells.map((_, i) => {
      const dy = oldRects[i] ? oldRects[i].top - newRects[i].top : 0;
      return Math.round(Math.abs(dy) / newRects[i].height);
    }));
    await new Promise(res => setTimeout(res, basePerTile * maxTiles + 80));
    newCells.forEach(cell => { cell.style.transition = ''; cell.style.transform = ''; });
  }
  updateUI();
  processing=false;
}
function renderSwapAnimation(i1,i2,success){
  const cells = boardEl.children;
  const cell1 = cells[i1];
  const cell2 = cells[i2];
  if(!cell1 || !cell2) return;
  const pos1 = cell1.getBoundingClientRect();
  const pos2 = cell2.getBoundingClientRect();
  const dx = pos2.left - pos1.left;
  const dy = pos2.top - pos1.top;
  cell1.style.transition = 'transform 300ms ease';
  cell2.style.transition = 'transform 300ms ease';
  cell1.style.transform = `translate(${dx}px,${dy}px)`;
  cell2.style.transform = `translate(${-dx}px,${-dy}px)`;
  setTimeout(()=> {
    cell1.style.transition = ''; cell2.style.transition = '';
    cell1.style.transform = ''; cell2.style.transform = '';
    if(!success) renderBoard();
  }, 300);
}
function isAdjacent(i1,i2){const [r1,c1]=rc(i1),[r2,c2]=rc(i2);return Math.abs(r1-r2)+Math.abs(c1-c2)===1;}
function renderBoardInitial(){board=generateBoard(); renderBoard();}
renderBoardInitial(); updateUI();
document.getElementById('startBtn').addEventListener('click',startGame);
const muteBtn=document.getElementById('muteBtn');
let muted=false;
muteBtn.addEventListener('click',()=>{
  muted=!muted;
  bgm.muted=muted; sndClear.muted=muted; sndStart.muted=muted;
  muteBtn.textContent=muted?'🔈':'🔇';
});
const pauseOverlay=document.getElementById('pauseOverlay');
const pauseBtn=document.getElementById('pauseBtn');
const resumeBtn=document.getElementById('resumeBtn');
pauseBtn.addEventListener('click',()=>{
  if(!running) return;
  clearInterval(timerId); running=false; bgm.pause();
  document.getElementById('pauseText').textContent='一時停止中';
  pauseOverlay.style.display='flex';
});
resumeBtn.addEventListener('click',()=>{
  running=true; pauseOverlay.style.display='none';
  bgm.play().catch(()=>{});
  timerId=setInterval(()=>{
    timeLeft--;
    if(timeLeft<=0){ clearInterval(timerId); running=false; showGameOver(); }
    updateUI();
  },1000);
});
document.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});
</script>
</body>
</html>
