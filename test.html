<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Match-3 Mobile Swipe</title>
<style>
:root {
  --cols:8;
  --rows:8;
  --tile-size:11vw;
}
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  overflow-x: hidden;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
  background: #111;
  color: white;
  font-family: sans-serif;
  height: 100vh;
}
.wrap {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}
.ui {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5vw;
  font-size: 3.6vw;
  font-weight: 600;
}
.panel {
  background: rgba(255,255,255,0.04);
  padding: 0.8vw 1.5vw;
  border-radius: 12px;
  min-width: 28vw;
  text-align: center;
}
#combo {
  color: #ffde59;
  font-weight: 900;
  font-size: 4.4vw;
}
.board {
  background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent);
  padding: 6px;
  border-radius: 10px;
  display: grid;
  grid-template-columns: repeat(var(--cols), var(--tile-size));
  gap: 4px;
  touch-action: none;
  box-sizing: border-box;
}
.cell {
  width: var(--tile-size);
  height: var(--tile-size);
  border-radius: 8px;
  overflow: hidden;
  background: #111a2a;
  display:flex;
  align-items:center;
  justify-content:center;
}
.cell img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  pointer-events:none;
}
@keyframes vanish {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.25); opacity: 0.6; }
  100% { transform: scale(0); opacity: 0; }
}
.vanish {
  animation: vanish 380ms cubic-bezier(.2,.9,.3,1) forwards;
}
.drop {
  transition: transform 420ms cubic-bezier(.2,.8,.3,1);
}
.start-overlay, #gameOverOverlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.35);
  border-radius: 10px;
  flex-direction: column;
  z-index: 10;
}
.start-btn {
  background: linear-gradient(90deg,#ff7ab6,#7b61ff);
  border: none;
  padding: 14px 26px;
  border-radius: 999px;
  font-size: 1.8rem;
  color: #fff;
  cursor: pointer;
}
#gameOverOverlay {
  font-size: 10vw;
  font-weight: 900;
  color: #fff;
  flex-wrap: wrap;
  gap: 1vw;
  text-align: center;
  line-height: 1.1;
}
.footer-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1rem;
}
.rules-table table {
  border-collapse: collapse;
}
.pause-btn {
  background: none;
  border: none;
  font-size: 2rem;
  color: white;
  cursor: pointer;
}
.pause-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: black;
  z-index: 20;
}
.pause-overlay button {
  font-size: 2.5rem;
}
</style>
</head>
<body>
<div class="wrap">
<div class="ui">
  <div class="header">
    <div class="panel">Score: <span id="score">0</span></div>
    <div class="panel">残り <span id="time">60</span> 秒</div>
    <div class="panel"><span id="combo"></span></div>
  </div>
  <div id="boardWrap" style="position:relative;">
    <div id="board" class="board"></div>
    <div id="overlay" class="start-overlay">
      <button id="startBtn" class="start-btn">START</button>
    </div>
    <div id="gameOverOverlay" style="display:none;"></div>
  </div>
  <div class="footer">
    <div class="footer-row">
      <div class="rules-table">
        <table style="color: #fff; text-align: center;">
          <thead>
            <tr><th style="border-bottom: 2px solid #ffde59; padding: 0.5rem;">得点ルール</th>
                <th style="border-bottom: 2px solid #ffde59; padding: 0.5rem;">内容</th></tr>
          </thead>
          <tbody>
            <tr><td style="border-bottom: 1px solid #555;">3個消し</td><td style="border-bottom: 1px solid #555;">100点</td></tr>
            <tr><td style="border-bottom: 1px solid #555;">4個消し</td><td style="border-bottom: 1px solid #555;">200点</td></tr>
            <tr><td style="border-bottom: 1px solid #555;">5個消し</td><td style="border-bottom: 1px solid #555;">300点</td></tr>
            <tr><td style="border-bottom: 1px solid #555;">2連鎖目</td><td style="border-bottom: 1px solid #555;">得点×2倍</td></tr>
            <tr><td style="border-bottom: 1px solid #555;">3連鎖目</td><td style="border-bottom: 1px solid #555;">得点×3倍</td></tr>
            <tr><td style="border-bottom: 1px solid #555;">⋮</td><td style="border-bottom: 1px solid #555;">⋮</td></tr>
            <tr><td style="border-bottom: 1px solid #555;">10連鎖目</td><td style="border-bottom: 1px solid #555;">得点×10倍</td></tr>
          </tbody>
        </table>
      </div>
      <button id="pauseBtn" class="pause-btn">⏸</button>
    </div>
  </div>
</div>
</div>
<div id="pauseOverlay" class="pause-overlay" style="display:none;">
  <button id="resumeBtn" class="start-btn">▶</button>
</div>

<audio id="sndStart" src="s.mp3" preload="auto"></audio>
<audio id="sndClear" src="cc.mp3" preload="auto"></audio>
<audio id="bgm" src="bgm2.mp3" preload="auto" loop></audio>

<script>
const ROWS=8,COLS=8,TILE_TYPES=6,GAME_TIME=60;
let board=[],running=false,score=0,timeLeft=GAME_TIME,timerId=null,combo=1,processing=false;
const boardEl=document.getElementById('board');
const scoreEl=document.getElementById('score');
const timeEl=document.getElementById('time');
const comboEl=document.getElementById('combo');
const overlay=document.getElementById('overlay');
const startBtn=document.getElementById('startBtn');
const gameOverOverlay=document.getElementById('gameOverOverlay');
const sndStart=document.getElementById('sndStart');
const sndClear=document.getElementById('sndClear');
const bgm=document.getElementById('bgm');
bgm.volume=0.2;

function idx(r,c){return r*COLS+c}
function rc(i){return [Math.floor(i/COLS),i%COLS]}
function randInt(min,max){return Math.floor(Math.random()*(max-min+1))+min}

function generateBoard(){
  const b=new Array(ROWS*COLS).fill(0);
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      while(true){
        const t=randInt(1,TILE_TYPES);
        b[idx(r,c)]=t;
        let bad=false;
        if(c>=2&&b[idx(r,c-1)]===t&&b[idx(r,c-2)]===t)bad=true;
        if(r>=2&&b[idx(r-1,c)]===t&&b[idx(r-2,c)]===t)bad=true;
        if(!bad) break;
      }
    }
  }
  return b;
}

function findMatches(b){
  const toClear=new Set();
  for(let r=0;r<ROWS;r++){
    let runType=null,runStart=0,runLen=0;
    for(let c=0;c<COLS;c++){
      const t=b[idx(r,c)];
      if(t===runType) runLen++;
      else{
        if(runType && runLen>=3){
          for(let k=0;k<runLen;k++) toClear.add(idx(r,runStart+k));
        }
        runType=t;runStart=c;runLen=1;
      }
    }
    if(runType && runLen>=3){
      for(let k=0;k<runLen;k++) toClear.add(idx(r,runStart+k));
    }
  }
  for(let c=0;c<COLS;c++){
    let runType=null,runStart=0,runLen=0;
    for(let r=0;r<ROWS;r++){
      const t=b[idx(r,c)];
      if(t===runType) runLen++;
      else{
        if(runType && runLen>=3){
          for(let k=0;k<runLen;k++) toClear.add(idx(runStart+k,c));
        }
        runType=t;runStart=r;runLen=1;
      }
    }
    if(runType && runLen>=3){
      for(let k=0;k<runLen;k++) toClear.add(idx(runStart+k,c));
    }
  }
  return Array.from(toClear).sort((a,b)=>a-b);
}

function collapseBoard(b){
  const nb=b.slice();
  for(let c=0;c<COLS;c++){
    const col=[];
    for(let r=0;r<ROWS;r++){
      const v=nb[idx(r,c)];
      if(v!==0) col.push(v);
    }
    const missing=ROWS-col.length;
    const newTiles=Array.from({length: missing},()=> randInt(1,TILE_TYPES));
    const newCol=newTiles.concat(col);
    for(let r=0;r<ROWS;r++) nb[idx(r,c)]=newCol[r];
  }
  return nb;
}

function swapTiles(b,i1,i2){
  const nb=b.slice();
  [nb[i1],nb[i2]]=[nb[i2],nb[i1]];
  return nb;
}

function scoreForMatch(count){
  switch(count){
    case 3:return 100;
    case 4:return 200;
    case 5:return 300;
    default:return 0;
  }
}

function renderBoard(prevBoard){
  boardEl.innerHTML='';
  for(let i=0;i<board.length;i++){
    const t=board[i];
    const cell=document.createElement('div');
    cell.className='cell';
    cell.dataset.i=i;
    if(t>0){
      const img=document.createElement('img');
      img.src=`tile${t}.png`;
      if(prevBoard && prevBoard[i]===0){
        img.style.transform='translateY(-120%)';
        img.classList.add('drop');
        requestAnimationFrame(()=>{img.style.transform='translateY(0)';});
        img.addEventListener('transitionend',function te(){
          img.classList.remove('drop');
          img.style.transform='';
          img.removeEventListener('transitionend',te);
        });
      }
      cell.appendChild(img);
    }
    boardEl.appendChild(cell);
  }
}

function waitForAnimations(elements,timeout=600){
  return new Promise(resolve=>{
    if(!elements||elements.length===0) return resolve();
    let remaining=elements.length;
    const timers=[];
    const onEnd=(ev)=>{
      ev.currentTarget.removeEventListener('animationend',onEnd);
      remaining--;
      if(remaining<=0){
        timers.forEach(t=>clearTimeout(t));
        resolve();
      }
    };
    elements.forEach(el=>{
      if(!el){remaining--;return;}
      el.addEventListener('animationend',onEnd);
      const t=setTimeout(()=>{
        try{el.removeEventListener('animationend',onEnd);}catch(e){}
        remaining--;if(remaining<=0) resolve();
      },timeout);
      timers.push(t);
    });
    if(remaining<=0) resolve();
  });
}

function startGame(){
  bgm.currentTime=0; bgm.play().catch(()=>{});
  board=generateBoard();
  score=0; timeLeft=GAME_TIME; combo=1; processing=false;
  running=true;
  overlay.style.display='none';
  gameOverOverlay.style.display='none';
  updateUI();
  renderBoard();
  sndStart.currentTime=0; sndStart.play();
  timerId=setInterval(()=>{
    timeLeft--;
    if(timeLeft<=0){
      clearInterval(timerId);
      running=false;
      showGameOver();
    }
    updateUI();
  },1000);
}

function updateUI(){
  scoreEl.textContent=score;
  timeEl.textContent=timeLeft;
  comboEl.textContent=combo>1 ? `${combo}コンボ！` : '';
}

function showGameOver(){
  bgm.pause();
  gameOverOverlay.style.display='flex';
  gameOverOverlay.innerHTML=`<div>最終スコア</div>
    <div style="font-size: 15vw; font-weight: 900; margin-top: 0.5em;">${score}</div>
    <button id="restartBtn" class="start-btn">RESTART</button>`;
  overlay.style.display='none';
  document.getElementById('restartBtn').addEventListener('click',()=>{
    startGame(); gameOverOverlay.style.display='none';
  });
}

function isAdjacent(i1,i2){
  const [r1,c1]=rc(i1),[r2,c2]=rc(i2);
  return (Math.abs(r1-r2)+Math.abs(c1-c2))===1;
}

async function playerMove(i1,i2){
  if(!running||processing) return;
  if(!isAdjacent(i1,i2)) return;
  processing=true;
  let newBoard=swapTiles(board,i1,i2);
  let matches=findMatches(newBoard);
  if(matches.length===0){
    renderSwapAnimation(i1,i2,false);
    await delay(350);
    processing=false;
    return;
  }
  renderSwapAnimation(i1,i2,true);
  board=newBoard;
  sndClear.currentTime=0;sndClear.play();
  let chain=0;
  while(true){
    matches=findMatches(board);
    if(matches.length===0) break;
    chain++;
    sndClear.currentTime=0; sndClear.play();
    const groups=groupMatches(board,matches);
    let gained=0;
    for(let group of groups){
      const count=group.length;
      gained+=scoreForMatch(count)*Math.min(chain,10);
    }
    score+=gained;
    combo=Math.min(10,chain);
    const imgEls=matches.map(i=>{
      const cell=boardEl.querySelector(`.cell[data-i='${i}']`);
      return cell?cell.querySelector('img'):null;
    }).filter(Boolean);
    imgEls.forEach(img=>{
      img.classList.remove('vanish'); void img.offsetWidth;
      img.classList.add('vanish');
    });
    await waitForAnimations(imgEls,500);
    matches.forEach(idx=> board[idx]=0);
    const prevAfterClear=board.slice();
    board=collapseBoard(board);
    renderBoard(prevAfterClear);
    await delay(480);
  }
  updateUI();
  processing=false;
}

function renderSwapAnimation(i1,i2,success){
  const cells=boardEl.children;
  const cell1=cells[i1],cell2=cells[i2];
  if(!cell1||!cell2) return;
  const pos1=cell1.getBoundingClientRect();
  const pos2=cell2.getBoundingClientRect();
  const dx=pos2.left-pos1.left;
  const dy=pos2.top-pos1.top;
  cell1.style.transition='transform 300ms ease';
  cell2.style.transition='transform 300ms ease';
  cell1.style.transform=`translate(${dx}px,${dy}px)`;
  cell2.style.transform=`translate(${-dx}px,${-dy}px)`;
  setTimeout(()=>{
    cell1.style.transition='';cell2.style.transition='';
    cell1.style.transform='';cell2.style.transform='';
    if(!success) renderBoard();
  },300);
}

function delay(ms){return new Promise(res=>setTimeout(res,ms));}

function groupMatches(boardArr,indices){
  const adj={}; indices.forEach(i=> adj[i]=[]);
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  for(let i of indices){
    const [r,c]=rc(i);
    for(let [dr,dc] of dirs){
      const nr=r+dr,nc=c+dc,ni=idx(nr,nc);
      if(indices.includes(ni)) adj[i].push(ni);
    }
  }
  const visited=new Set(),groups=[];
  for(let i of indices){
    if(visited.has(i)) continue;
    const queue=[i],group=[];
    while(queue.length){
      const curr=queue.shift();
      if(visited.has(curr)) continue;
      visited.add(curr);group.push(curr);
      for(let n of adj[curr]) if(!visited.has(n)) queue.push(n);
    }
    groups.push(group);
  }
  return groups;
}

let touchStartIndex=null,touchStartX=0,touchStartY=0;
boardEl.addEventListener('touchstart',e=>{
  if(!running||processing) return;
  const target=e.target.closest('.cell');
  if(!target) return;
  touchStartIndex=Number(target.dataset.i);
  touchStartX=e.touches[0].clientX;
  touchStartY=e.touches[0].clientY;
  e.preventDefault();
},{passive:false});
boardEl.addEventListener('touchend',e=>{
  if(touchStartIndex===null||!running||processing){
    touchStartIndex=null;return;
  }
  const touch=e.changedTouches[0];
  const dx=touch.clientX-touchStartX;
  const dy=touch.clientY-touchStartY;
  if(Math.max(Math.abs(dx),Math.abs(dy))<20){
    touchStartIndex=null;return;
  }
  const [r,c]=rc(touchStartIndex);
  let tr=r,tc=c;
  if(Math.abs(dx)>Math.abs(dy)) tc += (dx>0)?1:-1;
  else tr += (dy>0)?1:-1;
  if(tr<0||tr>=ROWS||tc<0||tc>=COLS){touchStartIndex=null;return;}
  playerMove(touchStartIndex,idx(tr,tc));
  touchStartIndex=null;
},{passive:false});

function renderBoardInitial(){
  board=generateBoard();
  renderBoard();
}
renderBoardInitial();
updateUI();
startBtn.addEventListener('click',startGame);

// Pause/Resume
const pauseBtn=document.getElementById('pauseBtn');
const pauseOverlay=document.getElementById('pauseOverlay');
const resumeBtn=document.getElementById('resumeBtn');
pauseBtn.addEventListener('click',()=>{
  if(!running) return;
  clearInterval(timerId);
  running=false;
  bgm.pause();
  pauseOverlay.style.display='flex';
});
resumeBtn.addEventListener('click',()=>{
  running=true;
  pauseOverlay.style.display='none';
  bgm.play().catch(()=>{});
  timerId=setInterval(()=>{
    timeLeft--;
    if(timeLeft<=0){
      clearInterval(timerId);
      running=false;
      showGameOver();
    }
    updateUI();
  },1000);
});
</script>
</body>
</html>
